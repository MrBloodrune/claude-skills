<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Agent Scry — Observatory</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --surface-0: #08080a;
  --surface-1: #0f0f12;
  --surface-2: #141418;
  --surface-3: #1a1a1f;
  --border: rgba(255,255,255,0.06);
  --border-hover: rgba(255,255,255,0.10);
  --accent: #3b82f6;
  --text-primary: #e8e8ec;
  --text-dim: rgba(255,255,255,0.35);
  --green: #10b981;
  --red: #f43f5e;
  --amber: #eab308;
  --purple: #a78bfa;
  --tool-read: #60a5fa;
  --tool-edit: #eab308;
  --tool-bash: #22c55e;
  --tool-grep: #8b5cf6;
  --tool-glob: #6366f1;
  --tool-write: #10b981;
}

html, body {
  height: 100%;
  background: var(--surface-0);
  color: var(--text-primary);
  font-family: 'DM Sans', sans-serif;
  font-size: 13px;
  overflow: hidden;
}

#app {
  display: grid;
  grid-template-areas:
    "header    header"
    "stats     stats"
    "timeline  sidebar"
    "sankey    sidebar"
    "infobar   infobar";
  grid-template-columns: 1fr 340px;
  grid-template-rows: auto auto 1fr 1fr auto;
  height: 100vh;
  gap: 0;
  background: var(--surface-0);
}

/* ═══ HEADER ═══ */
header {
  grid-area: header;
  background: var(--surface-1);
  padding: 10px 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  border-bottom: 1px solid var(--border);
}

header h1 {
  font-family: 'DM Sans', sans-serif;
  font-size: 15px;
  font-weight: 700;
  letter-spacing: 1.5px;
  color: var(--text-primary);
}

header .controls {
  display: flex;
  align-items: center;
  gap: 12px;
}

header .status {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-dim);
}

header .status .dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--green);
  box-shadow: 0 0 6px var(--green);
}

header .status .dot.disconnected {
  background: var(--red);
  box-shadow: 0 0 6px var(--red);
}

.header-btn {
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid var(--border-hover);
  color: var(--accent);
  padding: 4px 10px;
  font-family: 'DM Sans', sans-serif;
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 1px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.15s;
}

.header-btn:hover {
  background: rgba(59, 130, 246, 0.2);
}

#session-select {
  background: var(--surface-2);
  color: var(--text-primary);
  border: 1px solid var(--border);
  padding: 4px 8px;
  font-family: 'DM Mono', monospace;
  font-size: 11px;
  border-radius: 4px;
}

/* ═══ PANELS ═══ */
.panel {
  background:
    radial-gradient(ellipse at 0% 0%, rgba(59,130,246,0.04) 0%, transparent 50%),
    radial-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
    var(--surface-0);
  background-size: 100% 100%, 20px 20px, 100% 100%;
  overflow: hidden;
  position: relative;
  border: 1px solid var(--border);
}

.panel-header {
  padding: 8px 16px;
  background: transparent;
  font-family: 'DM Sans', sans-serif;
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
}

#timeline-panel { grid-area: timeline; overflow-y: auto; }
#timeline-panel svg { width: 100%; }
#sankey-panel { grid-area: sankey; overflow: hidden; min-height: 0; }
#sankey-panel svg { display: block; width: 100%; height: 100%; }

.empty-state {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-dim);
  font-size: 13px;
  letter-spacing: 0.5px;
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.8; }
}

.reconnect-banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: linear-gradient(90deg, var(--red), #dc2626);
  color: white;
  text-align: center;
  padding: 6px;
  font-size: 12px;
  z-index: 1000;
  display: none;
}

.tooltip {
  position: absolute;
  background: var(--surface-2);
  border: 1px solid var(--border-hover);
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 11px;
  pointer-events: none;
  z-index: 100;
  max-width: 300px;
  line-height: 1.5;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
}

.tooltip .label { color: var(--accent); font-weight: 600; }
.tooltip .dim { color: var(--text-dim); }

/* ═══ STATS BAR ═══ */
#stats-panel {
  grid-area: stats;
  display: flex;
  padding: 12px 16px;
  gap: 12px;
  overflow: hidden;
  background: var(--surface-0);
  border-bottom: 1px solid var(--border);
}

.stats-cards {
  display: flex;
  gap: 12px;
  flex: 1;
}

.stat-card {
  flex: 1;
  background: var(--surface-2);
  border-radius: 8px;
  border: 1px solid var(--border);
  min-width: 0;
  overflow: hidden;
  transition: all 0.15s ease;
}

.stat-card:hover {
  border-color: var(--border-hover);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  transform: translateY(-1px);
}

.stat-card-accent {
  height: 2px;
  background: linear-gradient(to right, var(--accent), transparent);
}

.stat-card-inner {
  padding: 14px 18px;
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
}

.stat-card .title {
  font-family: 'DM Sans', sans-serif;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-dim);
  margin-bottom: 4px;
  font-weight: 500;
}

.stat-card .value {
  font-family: 'DM Mono', monospace;
  font-size: 22px;
  font-weight: 600;
  color: var(--text-primary);
}

.stat-card .secondary {
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 2px;
}

.stat-card .sparkline {
  height: 28px;
  flex-shrink: 0;
  opacity: 0.6;
}

.stat-card .sparkline path {
  fill: none;
  stroke: var(--accent);
  stroke-width: 1.5;
}

.progress-bar {
  height: 3px;
  background: rgba(255,255,255,0.06);
  border-radius: 2px;
  margin-top: 8px;
  overflow: hidden;
}

.progress-bar .fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--green));
  border-radius: 2px;
  transition: width 0.3s ease;
}

/* ═══ SIDEBAR ═══ */
#sidebar-panel {
  grid-area: sidebar;
  display: flex;
  flex-direction: column;
  background: var(--surface-1);
  border-left: 1px solid var(--border);
  overflow: hidden;
}

.sidebar-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
  background: var(--surface-1);
  flex-shrink: 0;
}

.sidebar-tab {
  flex: 1;
  padding: 10px 0;
  text-align: center;
  font-family: 'DM Sans', sans-serif;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-dim);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.15s;
  user-select: none;
}

.sidebar-tab:hover { color: var(--text-primary); }
.sidebar-tab.active {
  color: var(--text-primary);
  border-bottom-color: var(--accent);
  background: var(--surface-2);
}

.sidebar-content {
  flex: 1;
  overflow-y: auto;
  background: var(--surface-2);
}

.sidebar-pane { display: none; height: 100%; overflow-y: auto; padding: 8px; }
.sidebar-pane.active { display: block; }

/* Agent cards in sidebar */
.agent-card {
  background: var(--surface-2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px 12px;
  margin-bottom: 6px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.agent-card:hover {
  background: var(--surface-3);
  border-color: var(--border-hover);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  transform: translateY(-1px);
}

.agent-card.selected {
  border-color: var(--accent);
  background: rgba(59, 130, 246, 0.06);
}

.agent-card-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
}

.agent-card-name {
  font-family: 'DM Mono', monospace;
  font-size: 12px;
  font-weight: 700;
  color: var(--text-primary);
}

.agent-status-pill {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  font-family: 'DM Sans', sans-serif;
  font-size: 10px;
  padding: 2px 8px;
  border-radius: 10px;
  background: rgba(255,255,255,0.04);
}

.agent-status-pill .pill-dot {
  width: 5px;
  height: 5px;
  border-radius: 50%;
}

.agent-status-pill.running { color: var(--green); }
.agent-status-pill.running .pill-dot { background: var(--green); }
.agent-status-pill.success { color: var(--text-dim); }
.agent-status-pill.success .pill-dot { background: rgba(255,255,255,0.25); }
.agent-status-pill.error { color: var(--red); }
.agent-status-pill.error .pill-dot { background: var(--red); }

.agent-card-meta {
  display: flex;
  gap: 16px;
  font-family: 'DM Mono', monospace;
  font-size: 11px;
  color: var(--text-dim);
}

.agent-card-task {
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.badge {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 3px;
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 0.3px;
}

.badge.running { background: rgba(59, 130, 246, 0.15); color: var(--accent); }
.badge.success { background: rgba(16, 185, 129, 0.15); color: var(--green); }
.badge.error { background: rgba(244, 63, 94, 0.15); color: var(--red); }

/* Task list in sidebar */
.task-list { list-style: none; padding: 8px; }

.task-item {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  padding: 8px 10px;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.15s;
  border: 1px solid transparent;
}

.task-item:hover { background: rgba(59, 130, 246, 0.06); border-color: var(--border); }

.task-status-icon {
  flex-shrink: 0;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  margin-top: 1px;
}

.task-status-icon.pending { border: 1.5px solid var(--text-dim); color: var(--text-dim); }
.task-status-icon.in_progress { border: 1.5px solid var(--accent); color: var(--accent); animation: pulse 1.5s infinite; }
.task-status-icon.completed { background: var(--green); color: var(--surface-0); }
.task-status-icon.error { background: var(--red); color: var(--surface-0); }

.task-info { flex: 1; min-width: 0; }
.task-subject { font-size: 11px; color: var(--text-primary); font-weight: 500; }
.task-desc { font-size: 9px; color: var(--text-dim); margin-top: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.task-owner { font-size: 9px; color: var(--accent); margin-top: 2px; }

/* Plan panel in sidebar */
.plan-panel { padding: 16px; }
.plan-status-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 0.5px;
  margin-bottom: 12px;
}
.plan-status-badge.active { background: rgba(167, 139, 250, 0.15); color: var(--purple); }
.plan-status-badge.inactive { background: rgba(255, 255, 255, 0.04); color: var(--text-dim); }

.plan-content {
  background: rgba(0,0,0,0.2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 12px;
  font-size: 11px;
  line-height: 1.6;
  color: var(--text-primary);
  white-space: pre-wrap;
  word-break: break-word;
  max-height: 400px;
  overflow-y: auto;
}

.plan-empty {
  color: var(--text-dim);
  font-size: 12px;
  text-align: center;
  padding: 32px 16px;
}

/* ═══ SANKEY ═══ */
.sankey-link { fill: none; stroke-opacity: 0.15; transition: stroke-opacity 0.15s; }
.sankey-link:hover { stroke-opacity: 0.35; }
.sankey-link.dimmed { stroke-opacity: 0.03; }
.sankey-node rect { cursor: pointer; transition: opacity 0.15s; }
.sankey-node text {
  font-family: 'DM Mono', monospace; font-size: 10px;
  fill: white; font-weight: 400; pointer-events: none;
}
.sankey-node:hover rect { stroke: rgba(255,255,255,0.4); stroke-width: 1.5; }
.sankey-col-header {
  font-family: 'DM Sans', sans-serif; font-size: 9px;
  fill: rgba(255,255,255,0.35); text-anchor: middle;
}

/* ═══ TIMELINE ═══ */
.timeline-bar { cursor: pointer; }
.timeline-bar:hover { filter: brightness(1.2); }
.timeline-bar.dimmed { opacity: 0.2; }
.connector-line { stroke: var(--text-dim); stroke-dasharray: 3,3; stroke-width: 1; opacity: 0.3; }
.tool-segment { cursor: pointer; stroke: rgba(0,0,0,0.3); stroke-width: 1; }
.tool-segment:hover { filter: brightness(1.3) drop-shadow(0 0 4px currentColor); stroke: rgba(255,255,255,0.3); stroke-width: 1.5; }
.tool-segment.dimmed { opacity: 0.12; }
.tool-label { font-size: 9px; fill: rgba(255,255,255,0.9); pointer-events: none; font-weight: 600; letter-spacing: 0.3px; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }

.plan-mode-region { fill: rgba(167, 139, 250, 0.06); stroke: rgba(167, 139, 250, 0.2); stroke-dasharray: 4,4; }
.plan-mode-label { font-size: 9px; fill: var(--purple); font-weight: 600; letter-spacing: 1px; opacity: 0.7; }

.hover-line { stroke: rgba(59, 130, 246, 0.4); stroke-width: 1; stroke-dasharray: 3,3; pointer-events: none; }
.hover-label { font-size: 9px; fill: var(--accent); pointer-events: none; }

@keyframes dash {
  to { stroke-dashoffset: -20; }
}

.in-progress {
  stroke-dasharray: 8,4;
  animation: dash 1s linear infinite;
}

/* ═══ DETAIL DRAWER ═══ */
.detail-drawer {
  position: fixed;
  top: 0;
  right: -440px;
  width: 420px;
  height: 100vh;
  background: var(--surface-2);
  border-left: 1px solid var(--border-hover);
  z-index: 200;
  display: flex;
  flex-direction: column;
  transition: right 0.25s ease;
  box-shadow: -4px 0 32px rgba(0,0,0,0.6);
}

.detail-drawer.open { right: 0; }

.drawer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.drawer-header h2 {
  font-size: 13px;
  font-weight: 600;
  color: var(--accent);
  margin: 0;
}

.drawer-close {
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 18px;
  cursor: pointer;
  padding: 0 4px;
  line-height: 1;
}

.drawer-close:hover { color: var(--text-primary); }

.drawer-body {
  flex: 1;
  overflow-y: auto;
  padding: 0;
}

.drawer-section {
  border-bottom: 1px solid var(--border);
  padding: 12px 16px;
}

.drawer-section h3 {
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  margin-bottom: 8px;
  font-weight: 700;
}

.drawer-kv {
  display: grid;
  grid-template-columns: 80px 1fr;
  gap: 4px 8px;
  font-size: 11px;
}

.drawer-kv .k { color: var(--text-dim); }
.drawer-kv .v { color: var(--text-primary); word-break: break-all; }

.drawer-prompt {
  font-size: 11px;
  line-height: 1.5;
  white-space: pre-wrap;
  word-break: break-word;
  max-height: 200px;
  overflow-y: auto;
  color: var(--text-primary);
  background: rgba(0,0,0,0.2);
  padding: 8px;
  border-radius: 4px;
}

.drawer-tool-list { list-style: none; font-size: 11px; }
.drawer-tool-list li { padding: 6px 0; border-bottom: 1px solid var(--border); }
.drawer-tool-list li:last-child { border-bottom: none; }
.drawer-tool-name { color: var(--accent); font-weight: 600; }
.drawer-tool-error { color: var(--red); }
.drawer-tool-output {
  color: var(--text-dim);
  font-size: 10px;
  white-space: pre-wrap;
  max-height: 80px;
  overflow-y: auto;
  background: rgba(0,0,0,0.2);
  padding: 4px 6px;
  border-radius: 3px;
  margin-top: 4px;
}

.drawer-file-list { list-style: none; font-size: 11px; }
.drawer-file-list li { padding: 2px 0; }
.file-op { display: inline-block; width: 16px; font-weight: 700; font-size: 10px; }
.file-op.read { color: var(--accent); }
.file-op.write { color: var(--green); }
.file-op.edit { color: var(--amber); }

.drawer-error {
  background: rgba(244,63,94,0.08);
  border: 1px solid rgba(244,63,94,0.2);
  border-radius: 4px;
  padding: 6px 8px;
  margin-bottom: 6px;
  font-size: 11px;
  color: var(--red);
  white-space: pre-wrap;
  max-height: 100px;
  overflow-y: auto;
}

.drawer-loading {
  text-align: center;
  color: var(--text-dim);
  padding: 24px;
  font-size: 12px;
}

.token-bar {
  display: flex;
  height: 6px;
  border-radius: 3px;
  overflow: hidden;
  margin: 6px 0;
  background: rgba(255, 255, 255, 0.06);
}

.token-bar > div { height: 100%; }
.token-bar .input { background: var(--accent); }
.token-bar .output { background: var(--purple); }
.token-bar .cache-create { background: var(--amber); }
.token-bar .cache-read { background: var(--green); }

/* ═══ INFO BAR ═══ */
#info-bar {
  grid-area: infobar;
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 5px 16px;
  background: var(--surface-1);
  border-top: 1px solid var(--border);
  font-family: 'DM Mono', monospace;
  font-size: 10px;
  color: var(--text-dim);
}

.info-badge {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  border-radius: 3px;
  font-weight: 600;
  letter-spacing: 0.3px;
}

.info-badge.plan-mode {
  background: rgba(167, 139, 250, 0.12);
  color: var(--purple);
  display: none;
}

.info-badge.plan-mode.visible { display: inline-flex; }

.info-badge.error-count {
  background: rgba(244, 63, 94, 0.12);
  color: var(--red);
  display: none;
}

.info-badge.error-count.visible { display: inline-flex; }

.info-badge.tasks-count {
  background: rgba(59, 130, 246, 0.08);
  color: var(--accent);
}

.info-badge.compaction-count {
  background: rgba(234, 179, 8, 0.12);
  color: var(--amber);
  display: none;
}

.info-badge.compaction-count.visible { display: inline-flex; }

/* ═══ EVENTS TAB ═══ */
.event-log-controls {
  display: flex;
  gap: 6px;
  padding: 8px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.event-log-controls input, .event-log-controls select {
  background: var(--surface-2);
  color: var(--text-primary);
  border: 1px solid var(--border-hover);
  padding: 4px 8px;
  font-family: 'DM Sans', sans-serif;
  font-size: 10px;
  border-radius: 4px;
}

.event-log-controls input { flex: 1; }

.event-log-list {
  list-style: none;
  overflow-y: auto;
  flex: 1;
  font-size: 10px;
}

.event-log-item {
  display: flex;
  gap: 6px;
  align-items: baseline;
  padding: 4px 8px;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: background 0.1s;
}

.event-log-item:hover { background: rgba(59, 130, 246, 0.06); }
.event-log-item.highlighted { background: rgba(59, 130, 246, 0.15); border-left: 2px solid var(--accent); }

.event-log-time { color: var(--text-dim); font-size: 9px; white-space: nowrap; min-width: 40px; }
.event-log-type { font-size: 9px; font-weight: 700; padding: 1px 4px; border-radius: 2px; white-space: nowrap; }
.event-log-type.tool_start { background: rgba(59, 130, 246, 0.12); color: var(--accent); }
.event-log-type.tool_end { background: rgba(16, 185, 129, 0.12); color: var(--green); }
.event-log-type.agent_complete { background: rgba(167, 139, 250, 0.12); color: var(--purple); }
.event-log-type.compaction { background: rgba(234, 179, 8, 0.12); color: var(--amber); }
.event-log-type.session_start, .event-log-type.session_end { background: rgba(255, 255, 255, 0.04); color: var(--text-dim); }
.event-log-type.agent_spawn { background: rgba(249, 115, 22, 0.12); color: #f97316; }
.event-log-agent { color: var(--text-dim); white-space: nowrap; max-width: 60px; overflow: hidden; text-overflow: ellipsis; }
.event-log-detail { color: var(--text-primary); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* ═══ COMPACTION MARKERS ═══ */
.compaction-marker { stroke: var(--amber); stroke-width: 1.5; stroke-dasharray: 5,3; cursor: pointer; }
.compaction-marker:hover { stroke-width: 2.5; filter: drop-shadow(0 0 4px var(--amber)); }
.compaction-label { font-size: 9px; fill: var(--amber); font-weight: 700; cursor: pointer; }
.session-end-marker { stroke: rgba(255,255,255,0.4); stroke-width: 1; }
.session-end-label { font-size: 9px; fill: var(--text-dim); }

/* ═══ HIGHLIGHT LINE ═══ */
.highlight-line { stroke: var(--accent); stroke-width: 2; pointer-events: none; }
.highlight-label { font-size: 9px; fill: var(--accent); font-weight: 700; pointer-events: none; }

/* ═══ COMPACTION EPOCH ═══ */
.compaction-epoch { fill: rgba(234, 179, 8, 0.03); }

/* ═══ PLAN CYCLES ═══ */
.plan-cycle-card {
  background: rgba(0,0,0,0.2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 12px;
  margin-bottom: 8px;
  cursor: pointer;
  transition: all 0.15s;
}

.plan-cycle-card:hover { border-color: var(--purple); background: rgba(167, 139, 250, 0.04); }
.plan-cycle-card.highlighted { border-color: var(--purple); background: rgba(167, 139, 250, 0.08); }

.plan-cycle-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}

.plan-cycle-num { font-size: 12px; font-weight: 700; color: var(--purple); }
.plan-write-dot { fill: var(--purple); cursor: pointer; }
</style>
</head>
<body>
<div class="reconnect-banner" id="reconnect-banner">Disconnected — reconnecting...</div>
<div class="tooltip" id="tooltip" style="display:none"></div>

<div id="detail-drawer" class="detail-drawer">
  <div class="drawer-header">
    <h2 id="drawer-title">Agent Detail</h2>
    <button class="drawer-close" id="drawer-close">&times;</button>
  </div>
  <div class="drawer-body" id="drawer-body"></div>
</div>

<div id="app">
  <header>
    <h1>AGENT SCRY</h1>
    <div class="controls">
      <button class="header-btn" id="mem-btn">MEM</button>
      <select id="session-select"><option value="">Current session</option></select>
      <div class="status">
        <div class="dot" id="status-dot"></div>
        <span id="status-text">Connected</span>
      </div>
    </div>
  </header>

  <div id="stats-panel">
    <div class="stats-cards">
      <div class="stat-card">
        <div class="stat-card-accent"></div>
        <div class="stat-card-inner">
          <div>
            <div class="title">Tokens</div>
            <div class="value" id="val-tokens">0</div>
            <div class="secondary" id="sec-tokens">avg 0/agent</div>
          </div>
          <div class="sparkline"><svg id="spark-tokens"></svg></div>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-card-accent"></div>
        <div class="stat-card-inner">
          <div>
            <div class="title">Cost</div>
            <div class="value" id="val-cost">$0.00</div>
            <div class="secondary" id="sec-cost">avg $0.00/agent</div>
          </div>
          <div class="sparkline"><svg id="spark-cost"></svg></div>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-card-accent"></div>
        <div class="stat-card-inner">
          <div>
            <div class="title">Agents</div>
            <div class="value" id="val-agents">0</div>
            <div class="secondary" id="sec-agents">0 active</div>
          </div>
          <div class="sparkline"><svg id="spark-agents"></svg></div>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-card-accent"></div>
        <div class="stat-card-inner">
          <div>
            <div class="title">Duration</div>
            <div class="value" id="val-duration">0s</div>
            <div class="secondary" id="sec-duration">est. remaining: —</div>
          </div>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-card-accent"></div>
        <div class="stat-card-inner">
          <div>
            <div class="title">Efficiency</div>
            <div class="value" id="val-efficiency">—</div>
            <div class="secondary" id="sec-efficiency">&nbsp;</div>
            <div class="progress-bar"><div class="fill" id="efficiency-bar" style="width:0%"></div></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel" id="timeline-panel">
    <div class="panel-header" style="display:flex;align-items:center;justify-content:space-between">
      <span>Timeline</span>
      <span id="tool-legend" style="display:flex;gap:8px;font-size:9px;font-weight:400;letter-spacing:0"></span>
    </div>
    <div class="empty-state" id="timeline-empty">Waiting for events...</div>
    <svg id="timeline-svg"></svg>
  </div>

  <div class="panel" id="sankey-panel">
    <div class="panel-header">Flow</div>
    <div class="empty-state" id="sankey-empty">Waiting for events...</div>
    <svg id="sankey-svg"></svg>
  </div>

  <div id="sidebar-panel">
    <div class="sidebar-tabs">
      <div class="sidebar-tab active" data-tab="agents">Agents</div>
      <div class="sidebar-tab" data-tab="tasks">Tasks</div>
      <div class="sidebar-tab" data-tab="plan">Plan</div>
      <div class="sidebar-tab" data-tab="events">Events</div>
    </div>
    <div class="sidebar-content">
      <div class="sidebar-pane active" id="pane-agents">
        <div id="agent-cards-container"></div>
      </div>
      <div class="sidebar-pane" id="pane-tasks">
        <ul class="task-list" id="task-list"></ul>
      </div>
      <div class="sidebar-pane" id="pane-plan">
        <div class="plan-panel" id="plan-panel">
          <div class="plan-empty">No plan detected</div>
        </div>
      </div>
      <div class="sidebar-pane" id="pane-events" style="display:none;flex-direction:column;height:100%">
        <div class="event-log-controls">
          <input type="text" id="event-filter-text" placeholder="Filter events...">
          <select id="event-filter-type">
            <option value="">All types</option>
            <option value="tool_start">tool_start</option>
            <option value="tool_end">tool_end</option>
            <option value="agent_complete">agent_complete</option>
            <option value="agent_spawn">agent_spawn</option>
            <option value="compaction">compaction</option>
            <option value="session_start">session_start</option>
            <option value="session_end">session_end</option>
          </select>
        </div>
        <ul class="event-log-list" id="event-log-list"></ul>
      </div>
    </div>
  </div>

  <div id="info-bar">
    <span id="info-events">0 events</span>
    <span class="info-badge plan-mode" id="info-plan-mode">PLAN MODE</span>
    <span class="info-badge tasks-count" id="info-tasks">0 tasks</span>
    <span class="info-badge compaction-count" id="info-compactions">0 compactions</span>
    <span class="info-badge error-count" id="info-errors">0 errors</span>
  </div>
</div>

<script>
const state = {
  events: [],
  agents: new Map(),
  toolCalls: [],
  selectedAgentId: null,
  paused: false,
  sessionStart: null,
  tokenHistory: [],
  costHistory: [],
  agentCountHistory: [],
  sortCol: 'agent',
  sortAsc: true,
  timelineCollapsed: new Set(),
  tasks: new Map(),
  // Multi-plan support
  planCycles: [],
  planMode: false,
  activeTab: 'agents',
  // Compaction tracking
  compactions: [],
  // Session end
  sessionEndTime: null,
  // Event log + timeline sync
  highlightTimestamp: null,
  highlightedEventId: null,
  highlightedPlanCycle: null,
};

// --- Time formatting ---

function formatTime(ms, baseMs) {
  const sec = (ms - baseMs) / 1000;
  if (sec < 60) return sec.toFixed(1) + 's';
  if (sec < 3600) {
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return `${m}:${String(s).padStart(2, '0')}`;
  }
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = Math.floor(sec % 60);
  return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
}

function getTickInterval(rangeSeconds) {
  if (rangeSeconds < 60) return 5;
  if (rangeSeconds < 300) return 15;
  if (rangeSeconds < 3600) return 60;
  return Math.ceil(rangeSeconds / 10);
}

// --- Event ingestion ---

function ingestEvent(evt) {
  state.events.push(evt);

  if (!state.sessionStart) state.sessionStart = evt.timestamp;

  // Task/Plan data ingestion
  if (evt.task_data) ingestTaskData(evt);
  if (evt.plan_data) ingestPlanData(evt);

  if (evt.event_type === 'compaction') {
    state.compactions.push({ timestamp: evt.timestamp, trigger: evt.trigger || 'auto' });
  }

  if (evt.event_type === 'session_end') {
    state.sessionEndTime = evt.timestamp;
  }

  if (evt.event_type === 'session_start') {
    if (!state.agents.has(evt.agent_id || 'ag_main')) {
      state.agents.set(evt.agent_id || 'ag_main', {
        id: evt.agent_id || 'ag_main',
        parentId: null,
        label: 'main',
        task: 'Root session',
        tags: [],
        model: null,
        spawnTime: evt.timestamp,
        endTime: null,
        tokensIn: 0,
        tokensOut: 0,
        durationMs: 0,
        status: 'running',
        tools: [],
        contributesTo: [],
        transcriptPath: evt.transcript_path || null,
      });
    }
    return;
  }

  if (evt.event_type === 'agent_spawn' || (evt.event_type === 'tool_start' && evt.spawns_agent_id)) {
    const agentId = evt.spawns_agent_id || evt.agent_id;
    if (!state.agents.has(agentId)) {
      const isSpawn = !!evt.spawns_agent_id;
      state.agents.set(agentId, {
        id: agentId,
        parentId: isSpawn ? (evt.agent_id || null) : (evt.parent_agent_id || null),
        label: evt.agent_spawn_label || evt.agent_label || 'unknown',
        task: evt.agent_spawn_task || evt.task_description || '',
        tags: evt.task_tags || [],
        model: evt.agent_spawn_model || evt.model || null,
        spawnTime: evt.timestamp,
        endTime: null,
        tokensIn: 0,
        tokensOut: 0,
        durationMs: 0,
        status: 'running',
        tools: [],
        contributesTo: [],
      });
    }
  }

  if (evt.event_type === 'tool_start') {
    const agentId = evt.agent_id || 'ag_main';
    if (!state.agents.has(agentId)) {
      state.agents.set(agentId, {
        id: agentId, parentId: null, label: evt.agent_label || 'main',
        task: '', tags: [], model: null, spawnTime: evt.timestamp, endTime: null,
        tokensIn: 0, tokensOut: 0, durationMs: 0, status: 'running',
        tools: [], contributesTo: [],
      });
    }
    state.toolCalls.push({
      id: evt.id,
      agentId,
      toolName: evt.tool_name,
      startTime: evt.timestamp,
      endTime: null,
      params: evt.tool_params_summary || '',
      toolUseId: evt.tool_use_id || null,
      cwd: evt.cwd || null,
    });
  }

  if (evt.event_type === 'tool_end') {
    const tc = [...state.toolCalls].reverse().find(
      t => t.agentId === (evt.agent_id || 'ag_main') && t.toolName === evt.tool_name && !t.endTime
    );
    if (tc) {
      tc.endTime = evt.timestamp;
      tc.tokensIn = evt.tokens_in || 0;
      tc.tokensOut = evt.tokens_out || 0;
      tc.hasError = !!evt.has_error;
      tc.responseSummary = evt.tool_response_summary || '';
    }
  }

  if (evt.event_type === 'agent_complete') {
    const agent = state.agents.get(evt.agent_id);
    if (agent) {
      agent.endTime = evt.timestamp;
      agent.tokensIn = evt.tokens_in || 0;
      agent.tokensOut = evt.tokens_out || 0;
      agent.durationMs = evt.duration_ms || (evt.timestamp - agent.spawnTime);
      agent.status = evt.status || 'success';
      agent.contributesTo = evt.contributes_to || [];
      agent.tags = evt.task_tags || agent.tags;
      if (evt.model && !agent.model) agent.model = evt.model;
      if (evt.transcript_path) agent.transcriptPath = evt.transcript_path;
    }
  }

  updateHistories();
}

function ingestTaskData(evt) {
  const td = evt.task_data;
  if (!td) return;
  if (td.task_type === 'task_create') {
    const id = String(state.tasks.size + 1);
    state.tasks.set(id, {
      id,
      subject: td.subject,
      description: td.description || '',
      activeForm: td.activeForm || '',
      status: 'pending',
      owner: null,
      agentId: evt.agent_id || null,
      createdAt: evt.timestamp,
    });
  } else if (td.task_type === 'task_update') {
    const task = state.tasks.get(td.taskId);
    if (task) {
      if (td.status) task.status = td.status;
      if (td.owner) task.owner = td.owner;
      if (td.subject) task.subject = td.subject;
    }
  } else if (td.task_type === 'task_list' && Array.isArray(td.tasks)) {
    for (const t of td.tasks) {
      const id = t.id || String(t.index);
      if (state.tasks.has(id)) {
        const existing = state.tasks.get(id);
        if (t.status) existing.status = t.status;
        if (t.subject) existing.subject = t.subject;
        if (t.owner) existing.owner = t.owner;
      } else {
        state.tasks.set(id, {
          id, subject: t.subject || '', description: t.description || '',
          activeForm: '', status: t.status || 'pending',
          owner: t.owner || null, agentId: null, createdAt: evt.timestamp,
        });
      }
    }
  } else if (td.task_type === 'task_get' && td.task) {
    const t = td.task;
    const id = t.id || t.taskId;
    if (id && state.tasks.has(id)) {
      const existing = state.tasks.get(id);
      if (t.status) existing.status = t.status;
      if (t.subject) existing.subject = t.subject;
    }
  }
}

function ingestPlanData(evt) {
  const pd = evt.plan_data;
  if (!pd) return;
  if (pd.plan_event === 'enter_plan_mode') {
    state.planMode = true;
    state.planCycles.push({ startTime: evt.timestamp, endTime: null, content: null, active: true, writeTime: null });
  } else if (pd.plan_event === 'exit_plan_mode') {
    state.planMode = false;
    const cycle = [...state.planCycles].reverse().find(c => c.active);
    if (cycle) { cycle.endTime = evt.timestamp; cycle.active = false; }
  } else if (pd.plan_event === 'plan_write') {
    const cycle = [...state.planCycles].reverse().find(c => c.active) || state.planCycles[state.planCycles.length - 1];
    if (cycle) {
      cycle.content = { filePath: pd.file_path, preview: pd.content_preview };
      cycle.writeTime = evt.timestamp;
    }
  }
}

function updateHistories() {
  const agents = [...state.agents.values()];
  const totalTokens = agents.reduce((s, a) => s + a.tokensIn + a.tokensOut, 0);
  const totalCost = agents.reduce((s, a) => s + (a.tokensIn * 15 / 1_000_000) + (a.tokensOut * 75 / 1_000_000), 0);

  state.tokenHistory.push(totalTokens);
  if (state.tokenHistory.length > 30) state.tokenHistory.shift();

  state.costHistory.push(totalCost);
  if (state.costHistory.length > 30) state.costHistory.shift();

  state.agentCountHistory.push(agents.filter(a => a.status === 'running').length);
  if (state.agentCountHistory.length > 30) state.agentCountHistory.shift();
}

// --- SSE connection ---

let evtSource = null;
let reconnectTimer = null;
let lastEventAt = 0;
let idleTimer = null;
const IDLE_THRESHOLD_MS = 15_000;

function finalizeRunningAgents() {
  const now = Date.now();
  let changed = false;
  for (const agent of state.agents.values()) {
    if (agent.status === 'running') {
      agent.endTime = agent.endTime || lastEventAt || now;
      agent.durationMs = agent.endTime - agent.spawnTime;
      agent.status = 'success';
      changed = true;
    }
  }
  for (const tc of state.toolCalls) {
    if (!tc.endTime) { tc.endTime = lastEventAt || now; changed = true; }
  }
  if (changed) render();
}

function resetIdleTimer() {
  lastEventAt = Date.now();
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = setTimeout(finalizeRunningAgents, IDLE_THRESHOLD_MS);
}

function connectSSE() {
  if (evtSource) evtSource.close();
  evtSource = new EventSource('/api/events');

  evtSource.addEventListener('message', (e) => {
    const evt = JSON.parse(e.data);
    ingestEvent(evt);
    resetIdleTimer();
    if (!state.paused) render();
  });

  evtSource.onopen = () => {
    document.getElementById('reconnect-banner').style.display = 'none';
    document.getElementById('status-dot').classList.remove('disconnected');
    document.getElementById('status-text').textContent = 'Connected';
    if (reconnectTimer) { clearInterval(reconnectTimer); reconnectTimer = null; }
  };

  evtSource.onerror = () => {
    document.getElementById('reconnect-banner').style.display = 'block';
    document.getElementById('status-dot').classList.add('disconnected');
    document.getElementById('status-text').textContent = 'Disconnected';
    evtSource.close();
    finalizeRunningAgents();
    if (!reconnectTimer) {
      reconnectTimer = setInterval(connectSSE, 3000);
    }
  };
}

async function loadSession(sessionId) {
  const url = sessionId ? `/api/session?id=${sessionId}` : '/api/session';
  const res = await fetch(url);
  const events = await res.json();
  state.events = [];
  state.agents.clear();
  state.toolCalls = [];
  state.sessionStart = null;
  state.tokenHistory = [];
  state.costHistory = [];
  state.agentCountHistory = [];
  state.tasks.clear();
  state.planCycles = [];
  state.planMode = false;
  state.compactions = [];
  state.sessionEndTime = null;
  state.highlightTimestamp = null;
  state.highlightedEventId = null;
  state.highlightedPlanCycle = null;
  events.forEach(e => ingestEvent(e));
  const lastTs = events.length ? events[events.length - 1].timestamp : 0;
  if (lastTs && (Date.now() - lastTs > IDLE_THRESHOLD_MS)) finalizeRunningAgents();
  render();
}

async function loadSessions() {
  try {
    const res = await fetch('/api/sessions');
    const sessions = await res.json();
    const sel = document.getElementById('session-select');
    sel.innerHTML = '<option value="">Current session</option>';
    sessions.forEach(s => {
      const opt = document.createElement('option');
      opt.value = s.id;
      opt.textContent = s.id;
      sel.appendChild(opt);
    });
  } catch {}
}

// --- Render orchestration ---

function render() {
  renderTimeline();
  renderSankey();
  renderStats();
  renderSidebar();
  renderInfoBar();
  renderEventLog();
}

// --- Timeline panel ---

function renderTimeline() {
  const container = document.getElementById('timeline-panel');
  const svg = d3.select('#timeline-svg');
  const emptyEl = document.getElementById('timeline-empty');

  if (state.agents.size === 0) {
    emptyEl.style.display = 'flex';
    svg.selectAll('*').remove();
    return;
  }
  emptyEl.style.display = 'none';

  const headerH = container.querySelector('.panel-header').offsetHeight;
  const width = container.clientWidth;
  const margin = { top: 10, right: 20, bottom: 28, left: 140 };

  svg.selectAll('*').remove();

  const agents = buildAgentTree();

  if (agents.length > 20 && state.timelineCollapsed.size === 0) {
    agents.filter(a => !a.parentId || !state.agents.has(a.parentId)).forEach(a => {
      const hasChildren = agents.some(c => c.parentId === a.id);
      if (hasChildren) state.timelineCollapsed.add(a.id);
    });
  }

  const visibleAgents = agents.filter(a => isVisible(a.id));
  const now = Date.now();

  const xMin = d3.min(visibleAgents, a => a.spawnTime) || now - 10000;
  const xMax = d3.max(visibleAgents, a => a.endTime || now) || now;
  const rangeSeconds = (xMax - xMin) / 1000;

  const x = d3.scaleLinear()
    .domain([xMin, xMax + (xMax - xMin) * 0.05])
    .range([margin.left, width - margin.right]);

  const rowH = 38;
  const maxH = Math.min(visibleAgents.length * rowH + margin.top + margin.bottom, window.innerHeight * 0.5);
  const contentH = margin.top + visibleAgents.length * rowH + margin.bottom;
  const height = Math.max(contentH, 100);
  svg.attr('viewBox', `0 0 ${width} ${height}`);
  svg.style('height', `${Math.min(height, maxH)}px`);
  const y = (i) => margin.top + i * rowH;

  const g = svg.append('g');

  const agentColors = {
    main: '#9ca3af', Explore: '#60a5fa', Plan: '#a78bfa',
    Bash: '#22c55e', 'general-purpose': '#eab308',
  };

  const toolColors = {
    Read: '#60a5fa', Write: '#10b981', Edit: '#eab308', Glob: '#6366f1',
    Grep: '#8b5cf6', Bash: '#22c55e', Task: '#f97316', NotebookEdit: '#fb923c',
    WebFetch: '#22d3ee', WebSearch: '#2dd4bf', Skill: '#e879f9',
    EnterPlanMode: '#a78bfa', ExitPlanMode: '#a78bfa',
    TaskCreate: '#6366f1', TaskUpdate: '#6366f1', TaskList: '#6366f1',
  };
  const defaultToolColor = '#94a3b8';

  // Compaction epochs — subtle background tint between compactions
  if (state.compactions.length > 0) {
    state.compactions.forEach((c, i) => {
      const epochStart = x(c.timestamp);
      const epochEnd = i < state.compactions.length - 1 ? x(state.compactions[i + 1].timestamp) : x(xMax + (xMax - xMin) * 0.05);
      g.append('rect')
        .attr('class', 'compaction-epoch')
        .attr('x', epochStart).attr('y', 0)
        .attr('width', Math.max(epochEnd - epochStart, 1)).attr('height', height - margin.bottom);
    });
  }

  // Multi-plan cycle regions
  state.planCycles.forEach((cycle, i) => {
    const pStart = x(cycle.startTime);
    const pEnd = x(cycle.endTime || now);
    const isHighlighted = state.highlightedPlanCycle === i;
    g.append('rect')
      .attr('class', 'plan-mode-region')
      .attr('x', pStart).attr('y', 0)
      .attr('width', Math.max(pEnd - pStart, 2)).attr('height', height - margin.bottom)
      .attr('rx', 4)
      .attr('fill', isHighlighted ? 'rgba(167, 139, 250, 0.14)' : 'rgba(167, 139, 250, 0.06)')
      .attr('stroke', isHighlighted ? 'rgba(167, 139, 250, 0.5)' : 'rgba(167, 139, 250, 0.2)')
      .attr('stroke-dasharray', isHighlighted ? 'none' : '4,4')
      .style('cursor', 'pointer')
      .on('click', () => highlightPlanCycle(i));
    g.append('text')
      .attr('class', 'plan-mode-label')
      .attr('x', pStart + 6).attr('y', 8)
      .attr('dy', '0.7em')
      .text(`PLAN ${i + 1}`)
      .style('cursor', 'pointer')
      .on('click', () => highlightPlanCycle(i));
    // Plan write dot
    if (cycle.writeTime) {
      g.append('circle')
        .attr('class', 'plan-write-dot')
        .attr('cx', x(cycle.writeTime)).attr('cy', 14)
        .attr('r', 4)
        .on('mouseenter', (e) => showTooltip(e, `<span class="label">Plan Write</span><br>${esc(cycle.content?.filePath || 'unknown')}`))
        .on('mouseleave', hideTooltip);
    }
  });

  visibleAgents.forEach((agent, i) => {
    const color = agentColors[agent.label] || '#9ca3af';
    const barY = y(i) + 3;
    const barH = rowH - 6;
    const startX = x(agent.spawnTime);
    const endX = x(agent.endTime || now);

    const depth = getDepth(agent.id);
    const indent = depth * 12;

    if (agent.parentId) {
      const parentIdx = visibleAgents.findIndex(a => a.id === agent.parentId);
      if (parentIdx >= 0) {
        g.append('line')
          .attr('class', 'connector-line')
          .attr('x1', startX).attr('y1', y(parentIdx) + rowH / 2)
          .attr('x2', startX).attr('y2', barY + barH / 2);
      }
    }

    const isDimmed = (state.selectedAgentId && state.selectedAgentId !== agent.id) ||
      (state.highlightedPlanCycle !== null && !isAgentInPlanCycle(agent, state.highlightedPlanCycle));
    g.append('rect')
      .attr('class', `timeline-bar ${isDimmed ? 'dimmed' : ''}`)
      .attr('x', startX).attr('y', barY)
      .attr('width', Math.max(endX - startX, 2)).attr('height', barH)
      .attr('rx', 4)
      .attr('fill', color).attr('opacity', 0.1)
      .on('click', () => selectAgent(agent.id))
      .on('mouseenter', (e) => showTooltip(e, agentTooltipHtml(agent)))
      .on('mouseleave', hideTooltip);

    g.append('line')
      .attr('x1', startX).attr('y1', barY + barH / 2)
      .attr('x2', endX).attr('y2', barY + barH / 2)
      .attr('stroke', color).attr('stroke-opacity', 0.12).attr('stroke-width', 1);

    const agentTools = state.toolCalls.filter(t => t.agentId === agent.id);
    agentTools.forEach(tc => {
      const tcStart = x(tc.startTime);
      const tcEnd = x(tc.endTime || now);
      const tcW = Math.max(tcEnd - tcStart, 3);
      const tcColor = tc.hasError ? '#f43f5e' : (toolColors[tc.toolName] || defaultToolColor);
      g.append('rect')
        .attr('class', `tool-segment ${isDimmed ? 'dimmed' : ''}`)
        .attr('x', tcStart).attr('y', barY + 1)
        .attr('width', tcW).attr('height', barH - 2)
        .attr('rx', 3)
        .attr('fill', tcColor).attr('opacity', tc.hasError ? 0.95 : 0.8)
        .on('mouseenter', (e) => {
          let tip = `<span class="label">${tc.toolName}</span>`;
          if (tc.hasError) tip += ' <span style="color:var(--red)">ERROR</span>';
          tip += `<br><span class="dim">${tc.params}</span>`;
          if (tc.responseSummary) tip += `<br><span class="dim">${tc.responseSummary}</span>`;
          if (tc.cwd && tc.toolName === 'Bash') tip += `<br><span class="dim">cwd: ${tc.cwd}</span>`;
          showTooltip(e, tip);
        })
        .on('mouseleave', hideTooltip);

      if (tcW > 28) {
        g.append('text')
          .attr('class', 'tool-label')
          .attr('x', tcStart + 4).attr('y', barY + barH / 2 + 1)
          .attr('dy', '0.3em')
          .attr('data-tcw', tcW)
          .text(tc.toolName.slice(0, Math.floor(tcW / 6)));
      }
    });

    if (!agent.endTime) {
      g.append('rect')
        .attr('class', 'pulse-cap')
        .attr('x', endX - 3).attr('y', barY)
        .attr('width', 3).attr('height', barH)
        .attr('fill', color).attr('opacity', 0.8)
        .attr('rx', 1);
    }

    const hasChildren = [...state.agents.values()].some(a => a.parentId === agent.id);
    const collapsed = state.timelineCollapsed.has(agent.id);
    const prefix = hasChildren ? (collapsed ? '+ ' : '- ') : '  ';

    g.append('text')
      .attr('x', margin.left - 8 + indent)
      .attr('y', barY + barH / 2 + 1)
      .attr('text-anchor', 'end')
      .attr('fill', color)
      .attr('font-size', '11px')
      .attr('cursor', hasChildren ? 'pointer' : 'default')
      .text(prefix + agent.label + (agent.id !== 'ag_main' ? ' ' + agent.id.slice(-6) : ''))
      .on('click', () => {
        if (hasChildren) {
          if (collapsed) state.timelineCollapsed.delete(agent.id);
          else state.timelineCollapsed.add(agent.id);
          render();
        }
      });
  });

  // Compaction markers
  state.compactions.forEach((c, i) => {
    const cx = x(c.timestamp);
    g.append('line')
      .attr('class', 'compaction-marker')
      .attr('x1', cx).attr('y1', 0).attr('x2', cx).attr('y2', height - margin.bottom)
      .on('click', () => openCompactionDrawer(i, c))
      .on('mouseenter', (e) => showTooltip(e, `<span class="label" style="color:var(--amber)">Compaction C${i + 1}</span><br>Trigger: ${c.trigger}<br>${formatTime(c.timestamp, xMin)}`))
      .on('mouseleave', hideTooltip);
    g.append('text')
      .attr('class', 'compaction-label')
      .attr('x', cx + 4).attr('y', height - margin.bottom - 4)
      .text(`C${i + 1}`)
      .style('cursor', 'pointer')
      .on('click', () => openCompactionDrawer(i, c));
  });

  // Session end marker
  if (state.sessionEndTime) {
    const sex = x(state.sessionEndTime);
    g.append('line')
      .attr('class', 'session-end-marker')
      .attr('x1', sex).attr('y1', 0).attr('x2', sex).attr('y2', height - margin.bottom);
    g.append('text')
      .attr('class', 'session-end-label')
      .attr('x', sex + 4).attr('y', height - margin.bottom - 4)
      .text('END');
  }

  // Highlight line (event sync)
  if (state.highlightTimestamp) {
    const hlx = x(state.highlightTimestamp);
    g.append('line')
      .attr('class', 'highlight-line')
      .attr('x1', hlx).attr('y1', 0).attr('x2', hlx).attr('y2', height - margin.bottom);
    g.append('text')
      .attr('class', 'highlight-label')
      .attr('x', hlx + 4).attr('y', 14)
      .text(formatTime(state.highlightTimestamp, xMin));
  }

  // Tool legend
  const usedTools = new Set(state.toolCalls.map(t => t.toolName));
  const legend = document.getElementById('tool-legend');
  legend.innerHTML = [...usedTools].filter(n => !['EnterPlanMode','ExitPlanMode','TaskCreate','TaskUpdate','TaskList','TaskGet'].includes(n)).slice(0, 8).map(name => {
    const c = toolColors[name] || defaultToolColor;
    const short = name.length > 10 ? name.slice(0, 9) + '\u2026' : name;
    return `<span style="display:flex;align-items:center;gap:3px" title="${name}"><span style="width:7px;height:7px;border-radius:2px;background:${c};display:inline-block;flex-shrink:0"></span>${short}</span>`;
  }).join('');

  // X-axis with smart formatting
  const tickInterval = getTickInterval(rangeSeconds);
  const xAxis = d3.axisBottom(x)
    .tickValues(d3.range(xMin, xMax + tickInterval * 1000, tickInterval * 1000))
    .tickFormat(d => formatTime(d, xMin));

  svg.append('g')
    .attr('class', 'x-axis')
    .attr('transform', `translate(0,${height - margin.bottom})`)
    .call(xAxis)
    .selectAll('text').attr('fill', '#555').attr('font-size', '9px');

  svg.selectAll('.domain, .tick line').attr('stroke', '#222');

  // Hover reference line
  const hoverG = svg.append('g').style('display', 'none');
  hoverG.append('line').attr('class', 'hover-line').attr('y1', 0).attr('y2', height - margin.bottom);
  hoverG.append('text').attr('class', 'hover-label').attr('y', -4);

  svg.on('mousemove', (e) => {
    const [mx] = d3.pointer(e);
    if (mx < margin.left || mx > width - margin.right) {
      hoverG.style('display', 'none');
      return;
    }
    hoverG.style('display', null);
    hoverG.select('line').attr('x1', mx).attr('x2', mx);
    const t = x.invert(mx);
    hoverG.select('text').attr('x', mx + 4).text(formatTime(t, xMin));
  }).on('mouseleave', () => hoverG.style('display', 'none'));

  // Zoom
  const zoom = d3.zoom()
    .scaleExtent([0.5, 50])
    .on('zoom', (event) => {
      const newX = event.transform.rescaleX(x);
      g.selectAll('.timeline-bar').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const ow = parseFloat(el.attr('data-ow'));
        el.attr('x', newX(ox)).attr('width', Math.max(newX(ox + ow) - newX(ox), 2));
      });
      g.selectAll('.tool-segment').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const ow = parseFloat(el.attr('data-ow'));
        el.attr('x', newX(ox)).attr('width', Math.max(newX(ox + ow) - newX(ox), 3));
      });
      g.selectAll('.tool-label').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const ow = parseFloat(el.attr('data-ow'));
        const newW = newX(ox + ow) - newX(ox);
        el.attr('x', newX(ox) + 4).attr('visibility', newW > 28 ? 'visible' : 'hidden');
        el.text(el.attr('data-name').slice(0, Math.floor(newW / 6)));
      });
      g.selectAll('.connector-line').each(function() {
        const el = d3.select(this);
        el.attr('x1', newX(parseFloat(el.attr('data-ox')))).attr('x2', newX(parseFloat(el.attr('data-ox'))));
      });
      g.selectAll('.pulse-cap').each(function() {
        const el = d3.select(this);
        el.attr('x', newX(parseFloat(el.attr('data-ox'))) - 1.5);
      });
      g.selectAll('.plan-mode-region').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const ow = parseFloat(el.attr('data-ow'));
        el.attr('x', newX(ox)).attr('width', Math.max(newX(ox + ow) - newX(ox), 2));
      });
      g.selectAll('.plan-mode-label').each(function() {
        const el = d3.select(this);
        el.attr('x', newX(parseFloat(el.attr('data-ox'))) + 6);
      });
      g.selectAll('.compaction-marker').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        el.attr('x1', newX(ox)).attr('x2', newX(ox));
      });
      g.selectAll('.compaction-label').each(function() {
        const el = d3.select(this);
        el.attr('x', newX(parseFloat(el.attr('data-ox'))) + 4);
      });
      g.selectAll('.session-end-marker').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        el.attr('x1', newX(ox)).attr('x2', newX(ox));
      });
      g.selectAll('.session-end-label').each(function() {
        const el = d3.select(this);
        el.attr('x', newX(parseFloat(el.attr('data-ox'))) + 4);
      });
      g.selectAll('.highlight-line').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        el.attr('x1', newX(ox)).attr('x2', newX(ox));
      });
      g.selectAll('.highlight-label').each(function() {
        const el = d3.select(this);
        el.attr('x', newX(parseFloat(el.attr('data-ox'))) + 4);
      });
      g.selectAll('.plan-write-dot').each(function() {
        const el = d3.select(this);
        el.attr('cx', newX(parseFloat(el.attr('data-ox'))));
      });
      g.selectAll('.compaction-epoch').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const ow = parseFloat(el.attr('data-ow'));
        el.attr('x', newX(ox)).attr('width', Math.max(newX(ox + ow) - newX(ox), 1));
      });
      svg.select('.x-axis').call(d3.axisBottom(newX).ticks(6).tickFormat(d => formatTime(d, xMin)));
      hoverG.style('display', 'none');
    });

  // Store original values for zoom
  g.selectAll('.timeline-bar').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x'))));
    el.attr('data-ow', x.invert(parseFloat(el.attr('x')) + parseFloat(el.attr('width'))) - x.invert(parseFloat(el.attr('x'))));
  });
  g.selectAll('.tool-segment').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x'))));
    el.attr('data-ow', x.invert(parseFloat(el.attr('x')) + parseFloat(el.attr('width'))) - x.invert(parseFloat(el.attr('x'))));
  });
  g.selectAll('.tool-label').each(function() {
    const el = d3.select(this);
    const lx = parseFloat(el.attr('x')) - 4;
    const tcw = parseFloat(el.attr('data-tcw'));
    el.attr('data-ox', x.invert(lx));
    el.attr('data-ow', x.invert(lx + tcw) - x.invert(lx));
    el.attr('data-name', el.text());
  });
  g.selectAll('.connector-line').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x1'))));
  });
  g.selectAll('.pulse-cap').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x')) + 1.5));
  });
  g.selectAll('.plan-mode-region').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x'))));
    el.attr('data-ow', x.invert(parseFloat(el.attr('x')) + parseFloat(el.attr('width'))) - x.invert(parseFloat(el.attr('x'))));
  });
  g.selectAll('.plan-mode-label').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x')) - 6));
  });
  g.selectAll('.compaction-marker').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x1'))));
  });
  g.selectAll('.compaction-label').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x')) - 4));
  });
  g.selectAll('.session-end-marker').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x1'))));
  });
  g.selectAll('.session-end-label').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x')) - 4));
  });
  g.selectAll('.highlight-line').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x1'))));
  });
  g.selectAll('.highlight-label').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x')) - 4));
  });
  g.selectAll('.plan-write-dot').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('cx'))));
  });
  g.selectAll('.compaction-epoch').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x'))));
    el.attr('data-ow', x.invert(parseFloat(el.attr('x')) + parseFloat(el.attr('width'))) - x.invert(parseFloat(el.attr('x'))));
  });

  svg.call(zoom);
}

function buildAgentTree() {
  const agents = [...state.agents.values()];
  if (agents.length === 0) return [];
  const roots = agents.filter(a => !a.parentId || !state.agents.has(a.parentId));
  const result = [];
  function walk(agent) {
    result.push(agent);
    agents.filter(a => a.parentId === agent.id).sort((a, b) => a.spawnTime - b.spawnTime).forEach(walk);
  }
  roots.sort((a, b) => a.spawnTime - b.spawnTime);
  roots.forEach(walk);
  return result;
}

function isVisible(agentId) {
  const agent = state.agents.get(agentId);
  if (!agent) return false;
  let current = agent;
  while (current.parentId && state.agents.has(current.parentId)) {
    if (state.timelineCollapsed.has(current.parentId)) return false;
    current = state.agents.get(current.parentId);
  }
  return true;
}

function getDepth(agentId) {
  let depth = 0;
  let agent = state.agents.get(agentId);
  while (agent && agent.parentId && state.agents.has(agent.parentId)) {
    depth++;
    agent = state.agents.get(agent.parentId);
  }
  return depth;
}

function agentTooltipHtml(a) {
  const tokens = a.tokensIn + a.tokensOut;
  const dur = a.endTime ? ((a.endTime - a.spawnTime) / 1000).toFixed(1) + 's' : 'running';
  let tip = `<span class="label">${a.label}</span> ${a.id.slice(-8)}`;
  if (a.model) tip += ` <span class="dim">[${a.model}]</span>`;
  tip += '<br>';
  if (a.task) tip += `<span class="dim">${a.task.slice(0, 80)}</span><br>`;
  tip += `Tokens: ${tokens.toLocaleString()} · Duration: ${dur}<br>Status: ${a.status}`;
  // Task associations
  const agentTasks = [...state.tasks.values()].filter(t =>
    (t.owner && a.id.includes(t.owner)) || (a.task && t.subject && fuzzyMatch(a.task, t.subject))
  );
  if (agentTasks.length > 0) {
    tip += `<br><span class="dim">Tasks: ${agentTasks.map(t => t.subject).join(', ')}</span>`;
  }
  return tip;
}

// --- Sankey panel ---

function renderSankey() {
  const container = document.getElementById('sankey-panel');
  const svg = d3.select('#sankey-svg');
  const emptyEl = document.getElementById('sankey-empty');

  if (state.agents.size === 0) {
    emptyEl.style.display = 'flex';
    svg.selectAll('*').remove();
    return;
  }
  emptyEl.style.display = 'none';

  const headerH = container.querySelector('.panel-header').offsetHeight;
  const width = container.clientWidth;
  const height = container.clientHeight - headerH;
  const margin = { top: 24, right: 100, bottom: 28, left: 60 };

  svg.attr('width', width).attr('height', height);
  svg.selectAll('*').remove();

  const agents = [...state.agents.values()];
  const totalTokens = agents.reduce((s, a) => s + a.tokensIn + a.tokensOut, 0) || 1;

  const agentColors = {
    main: '#9ca3af', Explore: '#60a5fa', Plan: '#a78bfa',
    Bash: '#22c55e', 'general-purpose': '#eab308',
  };

  const nodeMap = new Map();
  const links = [];

  // Column 0: Prompt
  const promptId = 'prompt_root';
  nodeMap.set(promptId, { id: promptId, name: 'Root Prompt', column: 0 });

  // Column 1: Phase grouping — group sub-agents by label
  const subAgents = agents.filter(a => a.parentId && state.agents.has(a.parentId));
  const phaseMap = new Map();
  const phaseNames = {
    'Explore': 'Explore codebase',
    'Plan': 'Plan architecture',
    'general-purpose': 'Implement features',
    'Bash': 'Run commands',
    'feature-dev:code-explorer': 'Explore codebase',
    'feature-dev:code-architect': 'Plan architecture',
    'feature-dev:code-reviewer': 'Review code',
  };

  subAgents.forEach(a => {
    const key = a.label || 'unknown';
    if (!phaseMap.has(key)) {
      phaseMap.set(key, {
        id: `phase_${key}`,
        name: phaseNames[key] || key,
        column: 1,
        tokens: 0,
        agents: [],
        color: agentColors[key] || '#9ca3af',
      });
    }
    const phase = phaseMap.get(key);
    phase.tokens += a.tokensIn + a.tokensOut;
    phase.agents.push(a);
  });

  if (phaseMap.size === 0) {
    phaseMap.set('unknown', { id: 'phase_unknown', name: 'Main Task', column: 1, tokens: totalTokens, agents: [], color: '#9ca3af' });
  }

  phaseMap.forEach((v, k) => nodeMap.set(v.id, v));
  phaseMap.forEach(phase => {
    links.push({ source: promptId, target: phase.id, value: Math.max(phase.tokens || 1, 1) });
  });

  // Column 2: Agent nodes — short IDs only
  const threshold = totalTokens * 0.05;
  let agentList = subAgents;
  let otherTokens = 0;

  if (subAgents.length > 20) {
    agentList = [];
    subAgents.forEach(a => {
      const tokens = a.tokensIn + a.tokensOut;
      if (tokens < threshold) otherTokens += tokens;
      else agentList.push(a);
    });
    if (otherTokens > 0) {
      const otherId = 'ag_other';
      nodeMap.set(otherId, { id: otherId, name: 'Other', column: 2, tokens: otherTokens, status: 'success', label: 'other' });
      phaseMap.forEach(phase => {
        links.push({ source: phase.id, target: otherId, value: Math.max(otherTokens / phaseMap.size, 1) });
      });
    }
  }

  agentList.forEach(a => {
    const tokens = a.tokensIn + a.tokensOut;
    nodeMap.set(a.id, { id: a.id, name: a.id.slice(-6), column: 2, tokens, status: a.status, label: a.label });
  });

  // Links: phase → agents (matched by label)
  agentList.forEach(a => {
    const tokens = a.tokensIn + a.tokensOut;
    const key = a.label || 'unknown';
    const phase = phaseMap.get(key);
    if (phase) {
      links.push({ source: phase.id, target: a.id, value: Math.max(tokens, 1) });
    }
  });

  // Column 3: File operation outcomes
  const outcomeMap = new Map();
  const outcomes = { read: 0, written: 0, errors: 0 };
  const agentOutcomes = new Map(); // agentId → { read, written, errors }

  agentList.forEach(a => {
    const ao = { read: 0, written: 0, errors: 0 };
    const tools = state.toolCalls.filter(t => t.agentId === a.id);
    tools.forEach(tc => {
      if (tc.hasError) { ao.errors++; outcomes.errors++; }
      else if (['Read', 'Glob', 'Grep', 'WebFetch', 'WebSearch'].includes(tc.toolName)) { ao.read++; outcomes.read++; }
      else if (['Write', 'Edit', 'NotebookEdit'].includes(tc.toolName)) { ao.written++; outcomes.written++; }
    });
    agentOutcomes.set(a.id, ao);
  });

  // Running agents that haven't finished get an "in progress" outcome
  const runningSubs = agentList.filter(a => a.status === 'running');
  const hasRunning = runningSubs.length > 0;

  if (outcomes.read > 0)
    outcomeMap.set('out_read', { id: 'out_read', name: `${outcomes.read} files read`, column: 3, status: 'success' });
  if (outcomes.written > 0)
    outcomeMap.set('out_written', { id: 'out_written', name: `${outcomes.written} files written`, column: 3, status: 'success' });
  if (outcomes.errors > 0)
    outcomeMap.set('out_errors', { id: 'out_errors', name: `${outcomes.errors} errors`, column: 3, status: 'error' });
  if (hasRunning)
    outcomeMap.set('out_running', { id: 'out_running', name: 'In Progress', column: 3, status: 'running' });

  // Fallback: if no file ops yet, create a generic outcome
  if (outcomeMap.size === 0) {
    const completed = agentList.filter(a => a.status !== 'running');
    if (completed.length > 0)
      outcomeMap.set('out_done', { id: 'out_done', name: 'Completed', column: 3, status: 'success' });
    else
      outcomeMap.set('out_running', { id: 'out_running', name: 'In Progress', column: 3, status: 'running' });
  }

  outcomeMap.forEach((v, k) => nodeMap.set(k, v));

  // Links: agents → outcomes
  agentList.forEach(a => {
    const ao = agentOutcomes.get(a.id);
    if (a.status === 'running' && outcomeMap.has('out_running')) {
      links.push({ source: a.id, target: 'out_running', value: Math.max(a.tokensIn + a.tokensOut, 1), agentStatus: 'running' });
      return;
    }
    let linked = false;
    if (ao.read > 0 && outcomeMap.has('out_read')) {
      links.push({ source: a.id, target: 'out_read', value: ao.read, agentStatus: a.status });
      linked = true;
    }
    if (ao.written > 0 && outcomeMap.has('out_written')) {
      links.push({ source: a.id, target: 'out_written', value: ao.written, agentStatus: a.status });
      linked = true;
    }
    if (ao.errors > 0 && outcomeMap.has('out_errors')) {
      links.push({ source: a.id, target: 'out_errors', value: ao.errors, agentStatus: a.status });
      linked = true;
    }
    // Fallback if agent had no categorized tool calls
    if (!linked) {
      const fallbackKey = outcomeMap.has('out_done') ? 'out_done' : outcomeMap.has('out_running') ? 'out_running' : outcomeMap.keys().next().value;
      if (fallbackKey) links.push({ source: a.id, target: fallbackKey, value: Math.max(a.tokensIn + a.tokensOut, 1), agentStatus: a.status });
    }
  });

  const nodes = [...nodeMap.values()];
  const nodeIndex = new Map(nodes.map((n, i) => [n.id, i]));

  const sankeyLinks = links
    .filter(l => nodeIndex.has(l.source) && nodeIndex.has(l.target) && l.source !== l.target)
    .map(l => ({ source: nodeIndex.get(l.source), target: nodeIndex.get(l.target), value: l.value, agentStatus: l.agentStatus }));

  if (nodes.length < 2 || sankeyLinks.length === 0) return;

  try {
    const dynamicPadding = nodes.length > 15 ? 4 : nodes.length > 8 ? 8 : 14;
    const sankeyGen = d3.sankey()
      .nodeId(d => d.index)
      .nodeAlign(d3.sankeyLeft)
      .nodeWidth(12)
      .nodePadding(dynamicPadding)
      .extent([[margin.left, margin.top], [width - margin.right, height - margin.bottom]]);

    const { nodes: sNodes, links: sLinks } = sankeyGen({
      nodes: nodes.map((n, i) => ({ ...n, index: i })),
      links: sankeyLinks,
    });

    // Per-column rect widths
    const colWidths = { 0: 120, 1: 130, 2: 60, 3: 110 };

    const nodeColor = (d) => {
      if (d.column === 0) return 'var(--accent)';
      if (d.column === 1) return d.color || 'var(--text-dim)';
      if (d.column === 3) {
        if (d.status === 'error') return 'var(--red)';
        if (d.status === 'running') return 'var(--accent)';
        if (d.id === 'out_read') return '#60a5fa';
        if (d.id === 'out_written') return 'var(--green)';
        return 'var(--green)';
      }
      if (d.label) {
        const colors = { main: '#9ca3af', Explore: '#60a5fa', Plan: '#a78bfa', Bash: '#22c55e', 'general-purpose': '#eab308' };
        return colors[d.label] || '#9ca3af';
      }
      return 'var(--text-dim)';
    };

    // Gradient defs for links
    const defs = svg.append('defs');
    sLinks.forEach((link, i) => {
      const grad = defs.append('linearGradient')
        .attr('id', `sg-${i}`).attr('x1', 0).attr('y1', 0).attr('x2', 1).attr('y2', 0);
      grad.append('stop').attr('offset', '0%').attr('stop-color', nodeColor(link.source));
      grad.append('stop').attr('offset', '100%').attr('stop-color', nodeColor(link.target));
    });

    const g = svg.append('g');

    // Column headers
    const headers = ['SOURCE', 'DECOMPOSITION', 'AGENTS', 'OUTCOMES'];
    headers.forEach((label, col) => {
      const colNodes = sNodes.filter(n => n.column === col);
      if (!colNodes.length) return;
      const cx = d3.mean(colNodes, n => (n.x0 + n.x1) / 2);
      g.append('text').attr('class', 'sankey-col-header')
        .attr('x', cx).attr('y', margin.top - 6).text(label);
    });

    // Links with gradient strokes
    g.selectAll('.sankey-link')
      .data(sLinks)
      .join('path')
      .attr('class', d => {
        let cls = 'sankey-link';
        const src = d.source;
        const tgt = d.target;
        if ((tgt && tgt.status === 'running') || (src && src.status === 'running')) cls += ' in-progress';
        if (state.selectedAgentId) {
          if (src.id !== state.selectedAgentId && tgt.id !== state.selectedAgentId) cls += ' dimmed';
        }
        if (state.highlightedPlanCycle !== null) {
          const srcAgent = state.agents.get(src.id);
          const tgtAgent = state.agents.get(tgt.id);
          const srcDimmed = srcAgent && !isAgentInPlanCycle(srcAgent, state.highlightedPlanCycle);
          const tgtDimmed = tgtAgent && !isAgentInPlanCycle(tgtAgent, state.highlightedPlanCycle);
          if (srcDimmed && tgtDimmed) cls += ' dimmed';
        }
        return cls;
      })
      .attr('d', d3.sankeyLinkHorizontal())
      .attr('stroke', (d, i) => `url(#sg-${i})`)
      .attr('stroke-width', d => Math.max(d.width, 1))
      .on('mouseenter', (e, d) => {
        showTooltip(e, `${d.source.name} → ${d.target.name}<br>Tokens: ${d.value.toLocaleString()}`);
      })
      .on('mouseleave', hideTooltip);

    // Node groups — translate to wide rect center
    const node = g.selectAll('.sankey-node')
      .data(sNodes)
      .join('g')
      .attr('class', 'sankey-node')
      .attr('transform', d => `translate(${d.x0},${d.y0})`);

    // Wide colored rects per column
    node.append('rect')
      .attr('x', d => -(colWidths[d.column] - (d.x1 - d.x0)) / 2)
      .attr('width', d => colWidths[d.column] || 12)
      .attr('height', d => Math.max(d.y1 - d.y0, 20))
      .attr('rx', 4)
      .attr('fill', nodeColor)
      .attr('opacity', d => {
        if (state.selectedAgentId && d.id !== state.selectedAgentId && d.column === 2) return 0.3;
        if (state.highlightedPlanCycle !== null && d.column === 2) {
          const agent = state.agents.get(d.id);
          if (agent && !isAgentInPlanCycle(agent, state.highlightedPlanCycle)) return 0.3;
        }
        return 0.8;
      })
      .on('click', (e, d) => {
        if (d.column === 2) selectAgent(d.id);
      });

    // Labels centered inside rects
    node.append('text')
      .attr('x', d => (colWidths[d.column] - (d.x1 - d.x0)) / 2)
      .attr('y', d => Math.max(d.y1 - d.y0, 20) / 2)
      .attr('dy', '0.35em')
      .attr('text-anchor', 'middle')
      .text(d => {
        const maxLen = { 0: 16, 1: 18, 2: 8, 3: 18 }[d.column] || 16;
        return d.name.length > maxLen ? d.name.slice(0, maxLen - 1) + '\u2026' : d.name;
      });

  } catch (e) {
    console.warn('Sankey render error:', e);
  }
}

function findTaskForAgent(agent) {
  for (const [id, task] of state.tasks) {
    if (task.owner && agent.id.includes(task.owner)) return task;
    if (agent.task && task.subject && fuzzyMatch(agent.task, task.subject)) return task;
  }
  return null;
}

// --- Stats panel ---

function renderStats() {
  const agents = [...state.agents.values()];
  const now = Date.now();

  const totalTokens = agents.reduce((s, a) => s + a.tokensIn + a.tokensOut, 0);
  const avgTokens = agents.length > 0 ? Math.round(totalTokens / agents.length) : 0;
  document.getElementById('val-tokens').textContent = totalTokens.toLocaleString();
  document.getElementById('sec-tokens').textContent = `avg ${avgTokens.toLocaleString()}/agent`;
  drawSparkline('spark-tokens', state.tokenHistory);

  const totalCost = agents.reduce((s, a) => s + (a.tokensIn * 15 / 1_000_000) + (a.tokensOut * 75 / 1_000_000), 0);
  const avgCost = agents.length > 0 ? totalCost / agents.length : 0;
  document.getElementById('val-cost').textContent = `$${totalCost.toFixed(2)}`;
  document.getElementById('sec-cost').textContent = `avg $${avgCost.toFixed(2)}/agent`;
  drawSparkline('spark-cost', state.costHistory);

  const active = agents.filter(a => a.status === 'running').length;
  const completed = agents.filter(a => a.status === 'success').length;
  const failed = agents.filter(a => a.status === 'error').length;
  document.getElementById('val-agents').textContent = agents.length;
  document.getElementById('sec-agents').textContent = `${active} active · ${completed} done · ${failed} err`;
  drawSparkline('spark-agents', state.agentCountHistory);

  if (state.sessionStart) {
    const elapsed = (now - state.sessionStart) / 1000;
    document.getElementById('val-duration').textContent = formatDuration(elapsed);
    const done = completed + failed;
    if (done > 0 && active > 0) {
      const avgDur = agents.filter(a => a.status !== 'running').reduce((s, a) => s + (a.durationMs || 0), 0) / done;
      document.getElementById('sec-duration').textContent = `est. remaining: ${formatDuration((active / done) * (avgDur / 1000))}`;
    } else {
      document.getElementById('sec-duration').textContent = `est. remaining: —`;
    }
  }

  const totalCompleted = agents.filter(a => a.status !== 'running').length;
  if (totalCompleted > 0) {
    const successRate = (completed / totalCompleted * 100).toFixed(0);
    document.getElementById('val-efficiency').textContent = `${successRate}%`;
    document.getElementById('efficiency-bar').style.width = `${successRate}%`;
  } else {
    document.getElementById('val-efficiency').textContent = '—';
    document.getElementById('efficiency-bar').style.width = '0%';
  }
}

// --- Sidebar ---

function renderSidebar() {
  renderAgentTable();
  renderTasks();
  renderPlanPanel();
}

function renderAgentTable() {
  const agents = [...state.agents.values()];
  const container = document.getElementById('agent-cards-container');
  const sorted = [...agents].sort((a, b) => {
    let va, vb;
    switch (state.sortCol) {
      case 'agent': va = a.label + a.id; vb = b.label + b.id; break;
      case 'tokens': va = a.tokensIn + a.tokensOut; vb = b.tokensIn + b.tokensOut; break;
      case 'duration': va = a.durationMs || 0; vb = b.durationMs || 0; break;
      case 'status': va = a.status; vb = b.status; break;
      default: va = a.id; vb = b.id;
    }
    if (typeof va === 'string') return state.sortAsc ? va.localeCompare(vb) : vb.localeCompare(va);
    return state.sortAsc ? va - vb : vb - va;
  });

  container.innerHTML = sorted.map(a => {
    const tokens = a.tokensIn + a.tokensOut;
    const dur = a.durationMs ? formatDuration(a.durationMs / 1000) : '—';
    const statusClass = a.status === 'running' ? 'running' : a.status === 'error' ? 'error' : 'success';
    const selected = state.selectedAgentId === a.id ? 'selected' : '';
    const statusLabel = a.status === 'running' ? 'Active' : a.status === 'error' ? 'Error' : 'Done';
    const modelTag = a.model ? ` <span style="font-family:'DM Mono',monospace;font-size:9px;color:var(--text-dim);opacity:0.7;margin-left:4px;padding:1px 5px;background:rgba(255,255,255,0.04);border-radius:3px">${esc(a.model)}</span>` : '';
    return `<div class="agent-card ${selected}" data-agent-id="${a.id}">
      <div class="agent-card-top">
        <span class="agent-card-name">${a.label} ${a.id.slice(-6)}${modelTag}</span>
        <span class="agent-status-pill ${statusClass}"><span class="pill-dot"></span>${statusLabel}</span>
      </div>
      <div class="agent-card-meta">
        <span>${tokens.toLocaleString()} tok</span>
        <span>${dur}</span>
      </div>
      ${a.task ? `<div class="agent-card-task" title="${esc(a.task)}">${esc(a.task.slice(0, 60))}</div>` : ''}
    </div>`;
  }).join('');
}

function renderTasks() {
  const list = document.getElementById('task-list');
  if (state.tasks.size === 0) {
    list.innerHTML = '<li style="padding:24px;text-align:center;color:var(--text-dim);font-size:12px">No tasks detected</li>';
    return;
  }

  list.innerHTML = [...state.tasks.values()].map(t => {
    const statusIcon = t.status === 'completed' ? '<span style="font-size:8px">&#10003;</span>'
      : t.status === 'error' ? '<span style="font-size:8px">&#10007;</span>'
      : t.status === 'in_progress' ? '<span style="font-size:8px">&#9654;</span>'
      : '';
    return `<li class="task-item" data-task-id="${t.id}">
      <div class="task-status-icon ${t.status}">${statusIcon}</div>
      <div class="task-info">
        <div class="task-subject">${esc(t.subject)}</div>
        ${t.description ? `<div class="task-desc">${esc(t.description)}</div>` : ''}
        ${t.owner ? `<div class="task-owner">${esc(t.owner)}</div>` : ''}
      </div>
    </li>`;
  }).join('');
}

function renderPlanPanel() {
  const panel = document.getElementById('plan-panel');
  if (state.planCycles.length === 0) {
    panel.innerHTML = '<div class="plan-empty">No plan detected</div>';
    return;
  }

  let html = '';
  state.planCycles.forEach((cycle, i) => {
    const isHighlighted = state.highlightedPlanCycle === i;
    const statusBadge = cycle.active
      ? '<span class="plan-status-badge active">ACTIVE</span>'
      : '<span class="plan-status-badge inactive">COMPLETED</span>';
    const base = state.sessionStart || cycle.startTime;
    const timeRange = `${formatTime(cycle.startTime, base)}${cycle.endTime ? ' — ' + formatTime(cycle.endTime, base) : ' — ongoing'}`;

    html += `<div class="plan-cycle-card ${isHighlighted ? 'highlighted' : ''}" data-cycle-idx="${i}">`;
    html += `<div class="plan-cycle-header"><span class="plan-cycle-num">Plan ${i + 1}</span>${statusBadge}</div>`;
    html += `<div style="font-size:10px;color:var(--text-dim);margin-bottom:6px">${timeRange}</div>`;
    if (cycle.content) {
      html += `<div style="font-size:10px;color:var(--text-dim);margin-bottom:4px">${esc(cycle.content.filePath)}</div>`;
      html += `<div class="plan-content" style="max-height:200px">${esc(cycle.content.preview)}</div>`;
    } else if (cycle.active) {
      html += '<div style="font-size:10px;color:var(--text-dim)">Waiting for plan content...</div>';
    }
    html += '</div>';
  });

  panel.innerHTML = html;
}

// --- Info bar ---

function renderInfoBar() {
  document.getElementById('info-events').textContent = `${state.events.length} events`;

  const planBadge = document.getElementById('info-plan-mode');
  if (state.planMode) planBadge.classList.add('visible');
  else planBadge.classList.remove('visible');

  const compBadge = document.getElementById('info-compactions');
  if (state.compactions.length > 0) {
    compBadge.textContent = `${state.compactions.length} compaction${state.compactions.length > 1 ? 's' : ''}`;
    compBadge.classList.add('visible');
  } else {
    compBadge.classList.remove('visible');
  }

  const tasksBadge = document.getElementById('info-tasks');
  if (state.tasks.size > 0) {
    const pending = [...state.tasks.values()].filter(t => t.status === 'pending').length;
    const inProg = [...state.tasks.values()].filter(t => t.status === 'in_progress').length;
    const parts = [`${state.tasks.size} tasks`];
    if (pending > 0) parts.push(`${pending} pending`);
    if (inProg > 0) parts.push(`${inProg} active`);
    tasksBadge.textContent = parts.join(' · ');
  } else {
    tasksBadge.textContent = '0 tasks';
  }

  const errorBadge = document.getElementById('info-errors');
  const errorCount = [...state.agents.values()].filter(a => a.status === 'error').length +
    state.toolCalls.filter(tc => tc.hasError).length;
  if (errorCount > 0) {
    errorBadge.textContent = `${errorCount} errors`;
    errorBadge.classList.add('visible');
  } else {
    errorBadge.classList.remove('visible');
  }
}

function drawSparkline(id, data) {
  if (data.length < 2) return;
  const svg = d3.select(`#${id}`);
  svg.selectAll('*').remove();
  const w = 64;
  const h = 28;
  svg.attr('width', w).attr('height', h);
  const xS = d3.scaleLinear().domain([0, data.length - 1]).range([0, w]);
  const yS = d3.scaleLinear().domain([0, d3.max(data) || 1]).range([h - 2, 2]);
  const line = d3.line().x((d, i) => xS(i)).y(d => yS(d)).curve(d3.curveMonotoneX);
  svg.append('path').datum(data).attr('d', line);
}

function formatDuration(seconds) {
  if (seconds < 60) return `${seconds.toFixed(0)}s`;
  if (seconds < 3600) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m}:${String(s).padStart(2, '0')}`;
  }
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  return `${h}:${String(m).padStart(2, '0')}:00`;
}

// --- Cross-panel interactions ---

function selectAgent(agentId) {
  if (state.selectedAgentId === agentId) {
    state.selectedAgentId = null;
    closeDrawer();
  } else {
    state.selectedAgentId = agentId;
    openAgentDrawer(agentId);
  }
  document.dispatchEvent(new CustomEvent('agent-select', { detail: { agentId: state.selectedAgentId } }));
  render();
}

// --- Detail drawer ---

function openAgentDrawer(agentId) {
  const agent = state.agents.get(agentId);
  if (!agent) return;

  const drawer = document.getElementById('detail-drawer');
  const body = document.getElementById('drawer-body');
  document.getElementById('drawer-title').textContent = `${agent.label} ${agentId.slice(-8)}`;
  drawer.classList.add('open');

  const tokens = agent.tokensIn + agent.tokensOut;
  const cost = ((agent.tokensIn * 15 / 1_000_000) + (agent.tokensOut * 75 / 1_000_000)).toFixed(3);
  const dur = agent.endTime ? ((agent.endTime - agent.spawnTime) / 1000).toFixed(1) + 's' : 'running';
  const agentTools = state.toolCalls.filter(t => t.agentId === agentId);
  const errorTools = agentTools.filter(t => t.hasError);

  let html = `<div class="drawer-section"><h3>Overview</h3><div class="drawer-kv">`;
  html += `<span class="k">Status</span><span class="v"><span class="badge ${agent.status === 'running' ? 'running' : agent.status === 'error' ? 'error' : 'success'}">${agent.status}</span></span>`;
  if (agent.model) html += `<span class="k">Model</span><span class="v">${esc(agent.model)}</span>`;
  html += `<span class="k">Task</span><span class="v">${esc(agent.task || '—')}</span>`;
  html += `<span class="k">Duration</span><span class="v">${dur}</span>`;
  html += `<span class="k">Tokens</span><span class="v">${tokens.toLocaleString()} (in: ${agent.tokensIn.toLocaleString()}, out: ${agent.tokensOut.toLocaleString()})</span>`;
  html += `<span class="k">Cost</span><span class="v">$${cost}</span>`;
  html += `<span class="k">Tools</span><span class="v">${agentTools.length} calls${errorTools.length ? `, ${errorTools.length} errors` : ''}</span>`;
  html += `</div></div>`;

  if (agentTools.length > 0) {
    html += `<div class="drawer-section"><h3>Tool Calls</h3><ul class="drawer-tool-list">`;
    for (const tc of agentTools) {
      html += `<li><span class="drawer-tool-name">${esc(tc.toolName)}</span>`;
      if (tc.hasError) html += ` <span class="drawer-tool-error">ERROR</span>`;
      if (tc.params) html += ` <span class="dim">${esc(tc.params)}</span>`;
      if (tc.responseSummary) html += `<div class="drawer-tool-output">${esc(tc.responseSummary)}</div>`;
      html += `</li>`;
    }
    html += `</ul></div>`;
  }

  html += `<div id="drawer-transcript"><div class="drawer-loading">Loading transcript...</div></div>`;
  body.innerHTML = html;
  loadTranscriptDetail(agentId, agent);
}

async function loadTranscriptDetail(agentId, agent) {
  const container = document.getElementById('drawer-transcript');
  if (!container) return;

  let transcriptPath = agent.transcriptPath;

  if (!transcriptPath && agent.parentId) {
    const parent = state.agents.get(agent.parentId);
    if (parent && parent.transcriptPath) {
      try {
        const res = await fetch(`/api/subagents?transcript=${encodeURIComponent(parent.transcriptPath)}`);
        const subagents = await res.json();
        const match = subagents.find(s => s.prompt && agent.task && fuzzyMatch(s.prompt, agent.task));
        if (match) transcriptPath = match.path;
      } catch {}
    }
  }

  if (!transcriptPath) {
    container.innerHTML = `<div class="drawer-section"><p class="dim" style="padding:8px 0;font-size:11px">No transcript available</p></div>`;
    return;
  }

  try {
    const res = await fetch(`/api/transcript?path=${encodeURIComponent(transcriptPath)}`);
    if (!res.ok) throw new Error(res.statusText);
    const data = await res.json();
    container.innerHTML = renderTranscriptDetail(data);
  } catch (err) {
    container.innerHTML = `<div class="drawer-section"><p class="dim" style="padding:8px 0;font-size:11px">Failed to load transcript: ${esc(err.message)}</p></div>`;
  }
}

function fuzzyMatch(a, b) {
  const al = a.toLowerCase().slice(0, 100);
  const bl = b.toLowerCase().slice(0, 100);
  if (al.includes(bl) || bl.includes(al)) return true;
  const aWords = al.split(/\s+/).filter(w => w.length > 3);
  const bWords = bl.split(/\s+/).filter(w => w.length > 3);
  const overlap = aWords.filter(w => bWords.includes(w));
  return overlap.length >= Math.min(2, Math.min(aWords.length, bWords.length));
}

function renderTranscriptDetail(data) {
  let html = '';

  if (data.prompt) {
    html += `<div class="drawer-section"><h3>Prompt</h3><div class="drawer-prompt">${esc(data.prompt)}</div></div>`;
  }

  if (data.usage) {
    const u = data.usage;
    const total = u.input_tokens + u.output_tokens;
    html += `<div class="drawer-section"><h3>Token Breakdown</h3><div class="drawer-kv">`;
    html += `<span class="k">Input</span><span class="v">${u.input_tokens.toLocaleString()}</span>`;
    html += `<span class="k">Output</span><span class="v">${u.output_tokens.toLocaleString()}</span>`;
    html += `<span class="k">Cache Write</span><span class="v">${u.cache_creation_input_tokens.toLocaleString()}</span>`;
    html += `<span class="k">Cache Read</span><span class="v">${u.cache_read_input_tokens.toLocaleString()}</span>`;
    html += `<span class="k">Cache Hit</span><span class="v">${u.cache_hit_rate}</span>`;
    html += `</div>`;
    if (total > 0) {
      const ip = (u.input_tokens / total * 100).toFixed(0);
      const op = (u.output_tokens / total * 100).toFixed(0);
      html += `<div class="token-bar"><div class="input" style="width:${ip}%"></div><div class="output" style="width:${op}%"></div></div>`;
      html += `<div style="font-size:10px;color:var(--text-dim)"><span style="color:var(--accent)">input</span> ${ip}% · <span style="color:var(--purple)">output</span> ${op}%</div>`;
    }
    html += `</div>`;
  }

  if (data.messages && data.messages.length > 0) {
    const toolUses = data.messages.filter(m => m.type === 'tool_use');
    const toolResults = data.messages.filter(m => m.type === 'tool_result');
    if (toolUses.length > 0) {
      html += `<div class="drawer-section"><h3>Transcript Tool Calls (${toolUses.length})</h3><ul class="drawer-tool-list">`;
      for (const tu of toolUses.slice(0, 50)) {
        const result = toolResults.find(r => r.tool_use_id === tu.id);
        html += `<li><span class="drawer-tool-name">${esc(tu.name)}</span>`;
        if (result && result.is_error) html += ` <span class="drawer-tool-error">ERROR</span>`;
        const filePath = tu.input?.file_path || tu.input?.pattern || tu.input?.command?.slice(0, 60) || '';
        if (filePath) html += ` <span class="dim">${esc(String(filePath).slice(0, 80))}</span>`;
        if (result && result.preview) html += `<div class="drawer-tool-output">${esc(result.preview.slice(0, 300))}</div>`;
        html += `</li>`;
      }
      if (toolUses.length > 50) html += `<li class="dim">... and ${toolUses.length - 50} more</li>`;
      html += `</ul></div>`;
    }
  }

  if (data.files && data.files.length > 0) {
    html += `<div class="drawer-section"><h3>Files Touched (${data.files.length})</h3><ul class="drawer-file-list">`;
    for (const f of data.files.slice(0, 40)) {
      const ops = f.ops.map(o => {
        const cls = o === 'W' ? 'write' : o === 'E' ? 'edit' : 'read';
        return `<span class="file-op ${cls}">${o}</span>`;
      }).join('');
      html += `<li>${ops} <span class="dim">${esc(f.path)}</span></li>`;
    }
    if (data.files.length > 40) html += `<li class="dim">... and ${data.files.length - 40} more</li>`;
    html += `</ul></div>`;
  }

  if (data.errors && data.errors.length > 0) {
    html += `<div class="drawer-section"><h3>Errors (${data.errors.length})</h3>`;
    for (const err of data.errors.slice(0, 10)) {
      html += `<div class="drawer-error">${esc(err.text)}</div>`;
    }
    if (data.errors.length > 10) html += `<p class="dim" style="font-size:11px">... and ${data.errors.length - 10} more</p>`;
    html += `</div>`;
  }

  return html || `<div class="drawer-section"><p class="dim" style="padding:8px 0;font-size:11px">No transcript detail available</p></div>`;
}

// --- Compaction drawer ---

function openCompactionDrawer(idx, compaction) {
  const drawer = document.getElementById('detail-drawer');
  const body = document.getElementById('drawer-body');
  document.getElementById('drawer-title').textContent = `Compaction C${idx + 1}`;
  drawer.classList.add('open');

  const base = state.sessionStart || compaction.timestamp;
  let html = `<div class="drawer-section"><h3>Overview</h3><div class="drawer-kv">`;
  html += `<span class="k">Trigger</span><span class="v">${esc(compaction.trigger)}</span>`;
  html += `<span class="k">Time</span><span class="v">${formatTime(compaction.timestamp, base)}</span>`;
  html += `<span class="k">Index</span><span class="v">C${idx + 1} of ${state.compactions.length}</span>`;
  html += `</div></div>`;
  html += `<div class="drawer-section" id="compaction-summary-section"><div class="drawer-loading">Loading compaction summary...</div></div>`;
  body.innerHTML = html;

  // Async load summary from main agent's transcript
  const mainAgent = state.agents.get('ag_main');
  if (mainAgent && mainAgent.transcriptPath) {
    fetch(`/api/compaction-summary?path=${encodeURIComponent(mainAgent.transcriptPath)}&index=${idx}`)
      .then(r => r.ok ? r.json() : null)
      .then(data => {
        const section = document.getElementById('compaction-summary-section');
        if (!section) return;
        if (data && data.summary) {
          section.innerHTML = `<h3>Compacted Summary</h3><div class="drawer-prompt">${esc(data.summary)}</div>`;
        } else {
          section.innerHTML = `<h3>Compacted Summary</h3><p class="dim" style="padding:8px 0;font-size:11px">Summary not available in transcript</p>`;
        }
      })
      .catch(() => {
        const section = document.getElementById('compaction-summary-section');
        if (section) section.innerHTML = `<h3>Compacted Summary</h3><p class="dim" style="padding:8px 0;font-size:11px">Summary pending</p>`;
      });
  } else {
    const section = document.getElementById('compaction-summary-section');
    if (section) section.innerHTML = `<h3>Compacted Summary</h3><p class="dim" style="padding:8px 0;font-size:11px">No transcript path available</p>`;
  }
}

// --- Plan cycle linking ---

function highlightPlanCycle(idx) {
  if (state.highlightedPlanCycle === idx) {
    state.highlightedPlanCycle = null;
    state.highlightTimestamp = null;
  } else {
    state.highlightedPlanCycle = idx;
    const cycle = state.planCycles[idx];
    if (cycle && cycle.writeTime) state.highlightTimestamp = cycle.writeTime;
    else state.highlightTimestamp = null;
    // Switch to Plan tab and scroll card into view
    switchTab('plan');
  }
  render();
  // Scroll plan card into view
  setTimeout(() => {
    const card = document.querySelector(`.plan-cycle-card[data-cycle-idx="${idx}"]`);
    if (card) card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }, 50);
}

function isAgentInPlanCycle(agent, cycleIdx) {
  if (cycleIdx === null || cycleIdx >= state.planCycles.length) return true;
  const cycle = state.planCycles[cycleIdx];
  const start = cycle.startTime;
  const end = cycle.endTime || Date.now();
  // Main agent is never dimmed
  if (agent.id === 'ag_main') return true;
  return agent.spawnTime >= start && agent.spawnTime <= end;
}

function switchTab(tabName) {
  document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.sidebar-pane').forEach(p => { p.classList.remove('active'); p.style.display = 'none'; });
  const tab = document.querySelector(`.sidebar-tab[data-tab="${tabName}"]`);
  const pane = document.getElementById(`pane-${tabName}`);
  if (tab) tab.classList.add('active');
  if (pane) { pane.classList.add('active'); pane.style.display = tabName === 'events' ? 'flex' : 'block'; }
  state.activeTab = tabName;
}

// --- Event log ---

function renderEventLog() {
  const list = document.getElementById('event-log-list');
  if (!list || state.activeTab !== 'events') return;

  const filterText = (document.getElementById('event-filter-text')?.value || '').toLowerCase();
  const filterType = document.getElementById('event-filter-type')?.value || '';

  let events = state.events;

  // Filter by selected agent
  if (state.selectedAgentId) {
    events = events.filter(e => e.agent_id === state.selectedAgentId || e.spawns_agent_id === state.selectedAgentId);
  }

  // Filter by type
  if (filterType) {
    events = events.filter(e => e.event_type === filterType);
  }

  // Filter by text
  if (filterText) {
    events = events.filter(e => {
      const searchable = [e.event_type, e.tool_name, e.agent_label, e.tool_params_summary, e.tool_response_summary, e.trigger].filter(Boolean).join(' ').toLowerCase();
      return searchable.includes(filterText);
    });
  }

  // Cap at last 500
  const capped = events.slice(-500);
  const base = state.sessionStart || (capped[0]?.timestamp || Date.now());

  list.innerHTML = capped.map(e => {
    const time = formatTime(e.timestamp, base);
    const typeClass = e.event_type || '';
    const agentLabel = e.agent_label || '';
    const detail = e.tool_name
      ? `${e.tool_name}${e.tool_params_summary ? ' ' + e.tool_params_summary : ''}${e.tool_response_summary ? ' → ' + e.tool_response_summary : ''}`.slice(0, 100)
      : e.trigger ? `trigger: ${e.trigger}`
      : e.task_description ? e.task_description.slice(0, 100)
      : e.status || '';
    const highlighted = state.highlightedEventId === e.id ? 'highlighted' : '';

    return `<li class="event-log-item ${highlighted}" data-event-id="${e.id}" data-timestamp="${e.timestamp}">
      <span class="event-log-time">${time}</span>
      <span class="event-log-type ${typeClass}">${e.event_type}</span>
      <span class="event-log-agent">${esc(agentLabel)}</span>
      <span class="event-log-detail">${esc(detail)}</span>
    </li>`;
  }).join('');
}

function esc(str) {
  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function closeDrawer() {
  document.getElementById('detail-drawer').classList.remove('open');
}

// --- Memory button ---

document.getElementById('mem-btn').addEventListener('click', async () => {
  const drawer = document.getElementById('detail-drawer');
  const body = document.getElementById('drawer-body');
  document.getElementById('drawer-title').textContent = 'MEMORY.md';
  drawer.classList.add('open');
  body.innerHTML = '<div class="drawer-loading">Loading memory...</div>';

  // Find project path from most recent cwd in events
  let projectPath = null;
  for (let i = state.events.length - 1; i >= 0; i--) {
    if (state.events[i].cwd) {
      projectPath = state.events[i].cwd;
      break;
    }
  }

  if (!projectPath) {
    body.innerHTML = '<div class="drawer-section"><p class="dim" style="padding:16px 0;font-size:12px">No project path detected from events</p></div>';
    return;
  }

  try {
    const res = await fetch(`/api/memory?project=${encodeURIComponent(projectPath)}`);
    const data = await res.json();
    if (res.ok) {
      body.innerHTML = `<div class="drawer-section"><h3>Memory</h3>
        <div style="font-size:10px;color:var(--text-dim);margin-bottom:8px">${esc(data.path)}</div>
        <div class="drawer-prompt">${esc(data.content || '(empty)')}</div>
      </div>`;
    } else {
      body.innerHTML = `<div class="drawer-section"><p class="dim" style="padding:16px 0;font-size:12px">${esc(data.error || 'Not found')}<br><span style="font-size:10px">${esc(data.path || '')}</span></p></div>`;
    }
  } catch (err) {
    body.innerHTML = `<div class="drawer-section"><p class="dim" style="padding:16px 0;font-size:12px">Failed to load: ${esc(err.message)}</p></div>`;
  }
});

// --- Event listeners ---

// Sidebar tabs
document.querySelectorAll('.sidebar-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    switchTab(tab.dataset.tab);
    if (tab.dataset.tab === 'events') renderEventLog();
  });
});

document.getElementById('agent-cards-container').addEventListener('click', (e) => {
  const card = e.target.closest('.agent-card');
  if (card) selectAgent(card.dataset.agentId);
});

// Task list click → highlight owning agent
document.getElementById('task-list').addEventListener('click', (e) => {
  const item = e.target.closest('.task-item');
  if (!item) return;
  const taskId = item.dataset.taskId;
  const task = state.tasks.get(taskId);
  if (!task) return;
  // Find agent that matches this task
  for (const agent of state.agents.values()) {
    if (agent.task && task.subject && fuzzyMatch(agent.task, task.subject)) {
      selectAgent(agent.id);
      return;
    }
  }
});

// Plan cycle card click
document.getElementById('plan-panel').addEventListener('click', (e) => {
  const card = e.target.closest('.plan-cycle-card');
  if (card) {
    const idx = parseInt(card.dataset.cycleIdx, 10);
    highlightPlanCycle(idx);
  }
});

// Event log click → timeline sync
document.getElementById('event-log-list').addEventListener('click', (e) => {
  const item = e.target.closest('.event-log-item');
  if (!item) return;
  const ts = parseInt(item.dataset.timestamp, 10);
  const id = item.dataset.eventId;
  state.highlightTimestamp = ts;
  state.highlightedEventId = id;
  render();
});

// Event log filters
document.getElementById('event-filter-text').addEventListener('input', () => renderEventLog());
document.getElementById('event-filter-type').addEventListener('change', () => renderEventLog());

document.getElementById('session-select').addEventListener('change', (e) => {
  const sid = e.target.value;
  if (sid) loadSession(sid);
  else loadSession();
});

document.querySelectorAll('.panel').forEach(panel => {
  panel.addEventListener('click', (e) => {
    if (e.target === panel || e.target.classList.contains('panel-header')) {
      state.selectedAgentId = null;
      state.highlightTimestamp = null;
      state.highlightedEventId = null;
      state.highlightedPlanCycle = null;
      closeDrawer();
      render();
    }
  });
});

document.getElementById('drawer-close').addEventListener('click', () => {
  state.selectedAgentId = null;
  closeDrawer();
  render();
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    state.selectedAgentId = null;
    state.highlightTimestamp = null;
    state.highlightedEventId = null;
    state.highlightedPlanCycle = null;
    closeDrawer();
    render();
  }
  if (e.key === ' ' && !e.target.closest('input, select, textarea')) {
    e.preventDefault();
    state.paused = !state.paused;
    document.getElementById('status-text').textContent = state.paused ? 'Paused' : 'Connected';
  }
});

document.addEventListener('agent-select', (e) => {
  const { agentId } = e.detail;
  if (agentId) {
    const card = document.querySelector(`.agent-card[data-agent-id="${agentId}"]`);
    if (card) card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
});

// --- Tooltip ---

function showTooltip(event, html) {
  const tip = document.getElementById('tooltip');
  tip.innerHTML = html;
  tip.style.display = 'block';
  const tx = Math.min(event.pageX + 12, window.innerWidth - 320);
  const ty = Math.min(event.pageY + 12, window.innerHeight - 100);
  tip.style.left = tx + 'px';
  tip.style.top = ty + 'px';
}

function hideTooltip() {
  document.getElementById('tooltip').style.display = 'none';
}

// --- Init ---

(async function init() {
  await loadSession();
  await loadSessions();
  connectSSE();
  render();

  setInterval(() => {
    if (!state.paused && state.agents.size > 0) render();
  }, 2000);
})();
</script>
</body>
</html>
