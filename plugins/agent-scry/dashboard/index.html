<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Scry — Observatory</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --surface-0: #08080a;
  --surface-1: #0f0f12;
  --surface-2: #141418;
  --surface-3: #1a1a1f;
  --border: rgba(255,255,255,0.06);
  --border-hover: rgba(255,255,255,0.10);
  --accent: #3b82f6;
  --text-primary: #e8e8ec;
  --text-dim: rgba(255,255,255,0.35);
  --green: #10b981;
  --red: #f43f5e;
  --amber: #eab308;
  --purple: #a78bfa;
  --tool-read: #60a5fa;
  --tool-edit: #eab308;
  --tool-bash: #22c55e;
  --tool-grep: #8b5cf6;
  --tool-glob: #6366f1;
  --tool-write: #10b981;
}

html, body {
  height: 100%;
  background: var(--surface-0);
  color: var(--text-primary);
  font-family: 'DM Sans', sans-serif;
  font-size: 13px;
  overflow: hidden;
}

#app {
  display: grid;
  grid-template-areas:
    "header    header"
    "stats     stats"
    "timeline  sidebar"
    "sankey    sidebar"
    "infobar   infobar";
  grid-template-columns: 1fr 340px;
  grid-template-rows: auto auto 1fr 1fr auto;
  height: 100vh;
  gap: 0;
  background: var(--surface-0);
}

/* ═══ HEADER ═══ */
header {
  grid-area: header;
  background: var(--surface-1);
  padding: 10px 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  border-bottom: 1px solid var(--border);
}

header h1 {
  font-family: 'DM Sans', sans-serif;
  font-size: 15px;
  font-weight: 700;
  letter-spacing: 1.5px;
  color: var(--text-primary);
}

header .controls {
  display: flex;
  align-items: center;
  gap: 12px;
}

header .status {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-dim);
}

header .status .dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--green);
  box-shadow: 0 0 6px var(--green);
}

header .status .dot.disconnected {
  background: var(--red);
  box-shadow: 0 0 6px var(--red);
}

.header-btn {
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid var(--border-hover);
  color: var(--accent);
  padding: 4px 10px;
  font-family: 'DM Sans', sans-serif;
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 1px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.15s;
}

.header-btn:hover {
  background: rgba(59, 130, 246, 0.2);
}

.session-controls {
  display: flex;
  align-items: center;
  gap: 6px;
}
.session-toggle {
  display: flex;
  border: 1px solid var(--border);
  border-radius: 4px;
  overflow: hidden;
}
.session-toggle button {
  background: var(--surface-2);
  color: var(--text-secondary);
  border: none;
  padding: 3px 10px;
  font-family: 'DM Mono', monospace;
  font-size: 10px;
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.session-toggle button.active {
  background: rgba(59, 130, 246, 0.25);
  color: var(--text-primary);
}
#session-select {
  background: var(--surface-2);
  color: var(--text-primary);
  border: 1px solid var(--border);
  padding: 4px 8px;
  font-family: 'DM Mono', monospace;
  font-size: 11px;
  border-radius: 4px;
  max-width: 280px;
}

/* ═══ PANELS ═══ */
.panel {
  background:
    radial-gradient(ellipse at 0% 0%, rgba(59,130,246,0.04) 0%, transparent 50%),
    radial-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
    var(--surface-0);
  background-size: 100% 100%, 20px 20px, 100% 100%;
  overflow: hidden;
  position: relative;
  border: 1px solid var(--border);
}

.panel-header {
  padding: 8px 16px;
  background: transparent;
  font-family: 'DM Sans', sans-serif;
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
}

#timeline-panel { grid-area: timeline; overflow-y: auto; }
#timeline-panel svg { width: 100%; }
#sankey-panel { grid-area: sankey; overflow: hidden; min-height: 0; }
#sankey-panel svg { display: block; width: 100%; height: 100%; }

.empty-state {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-dim);
  font-size: 13px;
  letter-spacing: 0.5px;
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.8; }
}

.reconnect-banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: linear-gradient(90deg, var(--red), #dc2626);
  color: white;
  text-align: center;
  padding: 6px;
  font-size: 12px;
  z-index: 1000;
  display: none;
}

.tooltip {
  position: absolute;
  background: var(--surface-2);
  border: 1px solid var(--border-hover);
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 11px;
  pointer-events: none;
  z-index: 100;
  max-width: 360px;
  line-height: 1.5;
  box-shadow: 0 4px 16px rgba(0,0,0,0.5);
}

.tooltip .label { color: var(--accent); font-weight: 600; }
.tooltip .dim { color: var(--text-dim); }
.tooltip .tip-list { margin: 2px 0 0 0; padding-left: 12px; list-style: disc; }
.tooltip .tip-list li { padding: 1px 0; }

/* ═══ STATS BAR ═══ */
#stats-panel {
  grid-area: stats;
  display: flex;
  padding: 12px 16px;
  gap: 12px;
  overflow: hidden;
  background: var(--surface-0);
  border-bottom: 1px solid var(--border);
}

.stats-cards {
  display: flex;
  gap: 12px;
  flex: 1;
}

.stat-card {
  flex: 1;
  background: var(--surface-2);
  border-radius: 8px;
  border: 1px solid var(--border);
  min-width: 0;
  overflow: hidden;
  transition: all 0.15s ease;
}

.stat-card:hover {
  border-color: var(--border-hover);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  transform: translateY(-1px);
}

.stat-card-accent {
  height: 2px;
  background: linear-gradient(to right, var(--accent), transparent);
}

.stat-card-inner {
  padding: 14px 18px;
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
}

.stat-card .title {
  font-family: 'DM Sans', sans-serif;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-dim);
  margin-bottom: 4px;
  font-weight: 500;
}

.stat-card .value {
  font-family: 'DM Mono', monospace;
  font-size: 22px;
  font-weight: 600;
  color: var(--text-primary);
}

.stat-card .secondary {
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 2px;
}

.stat-card .sparkline {
  height: 28px;
  flex-shrink: 0;
  opacity: 0.6;
}

.stat-card .sparkline path {
  fill: none;
  stroke: var(--accent);
  stroke-width: 1.5;
}

.progress-bar {
  height: 3px;
  background: rgba(255,255,255,0.06);
  border-radius: 2px;
  margin-top: 8px;
  overflow: hidden;
}

.progress-bar .fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--green));
  border-radius: 2px;
  transition: width 0.3s ease;
}

/* ═══ SIDEBAR ═══ */
#sidebar-panel {
  grid-area: sidebar;
  display: flex;
  flex-direction: column;
  background: var(--surface-1);
  border-left: 1px solid var(--border);
  overflow: hidden;
}

.sidebar-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
  background: var(--surface-1);
  flex-shrink: 0;
}

.sidebar-tab {
  flex: 1;
  padding: 10px 0;
  text-align: center;
  font-family: 'DM Sans', sans-serif;
  font-size: 12px;
  font-weight: 500;
  color: var(--text-dim);
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.15s;
  user-select: none;
}

.sidebar-tab:hover { color: var(--text-primary); }
.sidebar-tab.active {
  color: var(--text-primary);
  border-bottom-color: var(--accent);
  background: var(--surface-2);
}

.sidebar-content {
  flex: 1;
  overflow-y: auto;
  background: var(--surface-2);
}

.sidebar-pane { display: none; height: 100%; overflow-y: auto; padding: 8px; }
.sidebar-pane.active { display: block; }

/* Agent cards in sidebar */
.agent-card {
  background: var(--surface-2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px 12px;
  margin-bottom: 6px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.agent-card:hover {
  background: var(--surface-3);
  border-color: var(--border-hover);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  transform: translateY(-1px);
}

.agent-card.selected {
  border-color: var(--accent);
  background: rgba(59, 130, 246, 0.06);
}

.agent-card-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
}

.agent-card-name {
  font-family: 'DM Mono', monospace;
  font-size: 12px;
  font-weight: 700;
  color: var(--text-primary);
}

.agent-status-pill {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  font-family: 'DM Sans', sans-serif;
  font-size: 10px;
  padding: 2px 8px;
  border-radius: 10px;
  background: rgba(255,255,255,0.04);
}

.agent-status-pill .pill-dot {
  width: 5px;
  height: 5px;
  border-radius: 50%;
}

.agent-status-pill.running { color: var(--green); }
.agent-status-pill.running .pill-dot { background: var(--green); }
.agent-status-pill.success { color: var(--text-dim); }
.agent-status-pill.success .pill-dot { background: rgba(255,255,255,0.25); }
.agent-status-pill.error { color: var(--red); }
.agent-status-pill.error .pill-dot { background: var(--red); }

.agent-card-meta {
  display: flex;
  gap: 16px;
  font-family: 'DM Mono', monospace;
  font-size: 11px;
  color: var(--text-dim);
}

.agent-card-task {
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.badge {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 3px;
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 0.3px;
}

.badge.running { background: rgba(59, 130, 246, 0.15); color: var(--accent); }
.badge.success { background: rgba(16, 185, 129, 0.15); color: var(--green); }
.badge.error { background: rgba(244, 63, 94, 0.15); color: var(--red); }

/* Task list in sidebar */
.task-list { list-style: none; padding: 8px; }

.task-item {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  padding: 8px 10px;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.15s;
  border: 1px solid transparent;
}

.task-item:hover { background: rgba(59, 130, 246, 0.06); border-color: var(--border); }

.task-status-icon {
  flex-shrink: 0;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  margin-top: 1px;
}

.task-status-icon.pending { border: 1.5px solid var(--text-dim); color: var(--text-dim); }
.task-status-icon.in_progress { border: 1.5px solid var(--accent); color: var(--accent); animation: pulse 1.5s infinite; }
.task-status-icon.completed { background: var(--green); color: var(--surface-0); }
.task-status-icon.error { background: var(--red); color: var(--surface-0); }

.task-info { flex: 1; min-width: 0; }
.task-subject { font-size: 11px; color: var(--text-primary); font-weight: 500; }
.task-desc { font-size: 9px; color: var(--text-dim); margin-top: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.task-owner { font-size: 9px; color: var(--accent); margin-top: 2px; }

/* Plan panel in sidebar */
.plan-panel { padding: 16px; }
.plan-status-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 4px;
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 0.5px;
  margin-bottom: 12px;
}
.plan-status-badge.active { background: rgba(167, 139, 250, 0.15); color: var(--purple); }
.plan-status-badge.inactive { background: rgba(255, 255, 255, 0.04); color: var(--text-dim); }

.plan-content {
  background: rgba(0,0,0,0.2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 12px;
  font-size: 11px;
  line-height: 1.6;
  color: var(--text-primary);
  white-space: pre-wrap;
  word-break: break-word;
  max-height: 400px;
  overflow-y: auto;
}

.plan-empty {
  color: var(--text-dim);
  font-size: 12px;
  text-align: center;
  padding: 32px 16px;
}

/* ═══ SANKEY ═══ */
.metric-btn {
  padding: 2px 6px; border-radius: 3px; cursor: pointer;
  font-family: 'DM Mono', monospace; color: var(--text-dim);
  background: transparent; border: 1px solid var(--border);
  transition: all 0.15s;
}
.metric-btn:hover { border-color: var(--accent); color: var(--text-primary); }
.metric-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }
.sankey-link { fill: none; opacity: 0.15; stroke-linecap: round; transition: opacity 0.15s; }
.sankey-link:hover { opacity: 0.35; }
.sankey-link.dimmed { opacity: 0.04; }
.sankey-link.prompt-dimmed { opacity: 0.08; }
.sankey-node rect { cursor: pointer; transition: opacity 0.15s; }
.sankey-node text {
  font-family: 'DM Mono', monospace; font-size: 10px;
  fill: white; font-weight: 400; pointer-events: none;
}
.sankey-node:hover rect { stroke: rgba(255,255,255,0.4); stroke-width: 1.5; }
.sankey-node.prompt-dimmed rect { opacity: 0.3; }
.main-agent-node { stroke: #6b7280; stroke-width: 1; }
.sankey-col-header {
  font-family: 'DM Sans', sans-serif; font-size: 9px;
  fill: rgba(255,255,255,0.35); text-anchor: middle;
}

/* ═══ TIMELINE ═══ */
.timeline-bar { cursor: pointer; }
.timeline-bar:hover { filter: brightness(1.2); }
.timeline-bar.dimmed { opacity: 0.2; }
.connector-line { stroke: var(--text-dim); stroke-dasharray: 3,3; stroke-width: 1; opacity: 0.3; }
.tool-segment { cursor: pointer; stroke: rgba(0,0,0,0.3); stroke-width: 1; }
.tool-segment:hover { filter: brightness(1.3) drop-shadow(0 0 4px currentColor); stroke: rgba(255,255,255,0.3); stroke-width: 1.5; }
.tool-segment.dimmed { opacity: 0.12; }
.tool-label { font-size: 9px; fill: rgba(255,255,255,0.9); pointer-events: none; font-weight: 600; letter-spacing: 0.3px; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }

.plan-mode-region { fill: rgba(167, 139, 250, 0.06); stroke: rgba(167, 139, 250, 0.2); stroke-dasharray: 4,4; }
.plan-mode-label { font-size: 9px; fill: var(--purple); font-weight: 600; letter-spacing: 1px; opacity: 0.7; }

.hover-line { stroke: rgba(59, 130, 246, 0.4); stroke-width: 1; stroke-dasharray: 3,3; pointer-events: none; }
.hover-label { font-size: 9px; fill: var(--accent); pointer-events: none; }

@keyframes dash {
  to { stroke-dashoffset: -20; }
}

.in-progress {
  stroke-dasharray: 8,4;
  animation: dash 1s linear infinite;
}

/* ═══ DETAIL DRAWER ═══ */
.detail-drawer {
  position: fixed;
  top: 0;
  right: -440px;
  width: 420px;
  height: 100vh;
  background: var(--surface-2);
  border-left: 1px solid var(--border-hover);
  z-index: 200;
  display: flex;
  flex-direction: column;
  transition: right 0.25s ease;
  box-shadow: -4px 0 32px rgba(0,0,0,0.6);
}

.detail-drawer.open { right: 0; }

.drawer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.drawer-header h2 {
  font-size: 13px;
  font-weight: 600;
  color: var(--accent);
  margin: 0;
}

.drawer-close {
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 18px;
  cursor: pointer;
  padding: 0 4px;
  line-height: 1;
}

.drawer-close:hover { color: var(--text-primary); }

.drawer-body {
  flex: 1;
  overflow-y: auto;
  padding: 0;
}

.drawer-section {
  border-bottom: 1px solid var(--border);
  padding: 12px 16px;
}

.drawer-section h3 {
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text-dim);
  margin-bottom: 8px;
  font-weight: 700;
}

.drawer-kv {
  display: grid;
  grid-template-columns: 80px 1fr;
  gap: 4px 8px;
  font-size: 11px;
}

.drawer-kv .k { color: var(--text-dim); }
.drawer-kv .v { color: var(--text-primary); word-break: break-all; }

.drawer-prompt {
  font-size: 11px;
  line-height: 1.5;
  white-space: pre-wrap;
  word-break: break-word;
  max-height: 200px;
  overflow-y: auto;
  color: var(--text-primary);
  background: rgba(0,0,0,0.2);
  padding: 8px;
  border-radius: 4px;
}

.drawer-tool-list { list-style: none; font-size: 11px; }
.drawer-tool-list li { padding: 6px 0; border-bottom: 1px solid var(--border); }
.drawer-tool-list li:last-child { border-bottom: none; }
.drawer-tool-name { color: var(--accent); font-weight: 600; }
.drawer-tool-error { color: var(--red); }
.drawer-tool-output {
  color: var(--text-dim);
  font-size: 10px;
  white-space: pre-wrap;
  max-height: 80px;
  overflow-y: auto;
  background: rgba(0,0,0,0.2);
  padding: 4px 6px;
  border-radius: 3px;
  margin-top: 4px;
}

.drawer-file-list { list-style: none; font-size: 11px; }
.drawer-file-list li { padding: 2px 0; }
.file-op { display: inline-block; width: 16px; font-weight: 700; font-size: 10px; }
.file-op.read { color: var(--accent); }
.file-op.write { color: var(--green); }
.file-op.edit { color: var(--amber); }

.drawer-error {
  background: rgba(244,63,94,0.08);
  border: 1px solid rgba(244,63,94,0.2);
  border-radius: 4px;
  padding: 6px 8px;
  margin-bottom: 6px;
  font-size: 11px;
  color: var(--red);
  white-space: pre-wrap;
  max-height: 100px;
  overflow-y: auto;
}

.drawer-loading {
  text-align: center;
  color: var(--text-dim);
  padding: 24px;
  font-size: 12px;
}

.drawer-tool-card {
  padding: 6px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  margin-bottom: 4px;
  font-size: 11px;
}
.drawer-tool-card .dtc-top { display: flex; align-items: center; gap: 6px; }
.drawer-tool-card .dtc-name { font-weight: 600; }
.drawer-tool-card .dtc-params { color: var(--text-dim); font-size: 10px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 200px; }
.drawer-tool-card .dtc-meta { color: var(--text-dim); font-size: 10px; margin-top: 2px; display: flex; gap: 8px; }
.drawer-tool-card .dtc-error-badge { background: rgba(244,63,94,0.15); color: var(--red); padding: 1px 6px; border-radius: 3px; font-size: 9px; font-weight: 600; }
.drawer-cat-header { font-size: 10px; font-weight: 600; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; margin: 8px 0 4px; }

.drawer-agent-card {
  padding: 8px 10px;
  border: 1px solid var(--border);
  border-radius: 6px;
  margin-bottom: 6px;
  cursor: pointer;
  transition: border-color 0.15s;
}
.drawer-agent-card:hover { border-color: var(--border-hover); background: rgba(255,255,255,0.02); }
.drawer-agent-card .dac-top { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
.drawer-agent-card .dac-label { font-weight: 600; font-size: 11px; color: var(--text-primary); }
.drawer-agent-card .dac-id { font-family: 'DM Mono', monospace; font-size: 10px; color: var(--text-dim); }
.drawer-agent-card .dac-task { font-size: 10px; color: var(--text-dim); margin-top: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.drawer-agent-card .dac-meta { font-size: 10px; color: var(--text-dim); margin-top: 2px; display: flex; gap: 8px; }

.token-bar {
  display: flex;
  height: 6px;
  border-radius: 3px;
  overflow: hidden;
  margin: 6px 0;
  background: rgba(255, 255, 255, 0.06);
}

.token-bar > div { height: 100%; }
.token-bar .input { background: var(--accent); }
.token-bar .output { background: var(--purple); }
.token-bar .cache-create { background: var(--amber); }
.token-bar .cache-read { background: var(--green); }

/* ═══ INFO BAR ═══ */
#info-bar {
  grid-area: infobar;
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 5px 16px;
  background: var(--surface-1);
  border-top: 1px solid var(--border);
  font-family: 'DM Mono', monospace;
  font-size: 10px;
  color: var(--text-dim);
}

.info-badge {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  border-radius: 3px;
  font-weight: 600;
  letter-spacing: 0.3px;
}

.info-badge.plan-mode {
  background: rgba(167, 139, 250, 0.12);
  color: var(--purple);
  display: none;
}

.info-badge.plan-mode.visible { display: inline-flex; }

.info-badge.error-count {
  background: rgba(244, 63, 94, 0.12);
  color: var(--red);
  display: none;
}

.info-badge.error-count.visible { display: inline-flex; }

.info-badge.tasks-count {
  background: rgba(59, 130, 246, 0.08);
  color: var(--accent);
}

.info-badge.compaction-count {
  background: rgba(234, 179, 8, 0.12);
  color: var(--amber);
  display: none;
}

.info-badge.compaction-count.visible { display: inline-flex; }

/* ═══ EVENTS TAB ═══ */
.event-log-controls {
  display: flex;
  gap: 6px;
  padding: 8px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.event-log-controls input, .event-log-controls select {
  background: var(--surface-2);
  color: var(--text-primary);
  border: 1px solid var(--border-hover);
  padding: 4px 8px;
  font-family: 'DM Sans', sans-serif;
  font-size: 10px;
  border-radius: 4px;
}

.event-log-controls input { flex: 1; }

.event-log-list {
  list-style: none;
  overflow-y: auto;
  flex: 1;
  font-size: 10px;
}

.event-log-item {
  display: flex;
  gap: 6px;
  align-items: baseline;
  padding: 4px 8px;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: background 0.1s;
}

.event-log-item:hover { background: rgba(59, 130, 246, 0.06); }
.event-log-item.highlighted { background: rgba(59, 130, 246, 0.15); border-left: 2px solid var(--accent); }

.event-log-time { color: var(--text-dim); font-size: 9px; white-space: nowrap; min-width: 40px; }
.event-log-type { font-size: 9px; font-weight: 700; padding: 1px 4px; border-radius: 2px; white-space: nowrap; }
.event-log-type.tool_start { background: rgba(59, 130, 246, 0.12); color: var(--accent); }
.event-log-type.tool_end { background: rgba(16, 185, 129, 0.12); color: var(--green); }
.event-log-type.agent_complete { background: rgba(167, 139, 250, 0.12); color: var(--purple); }
.event-log-type.compaction { background: rgba(234, 179, 8, 0.12); color: var(--amber); }
.event-log-type.session_start, .event-log-type.session_end { background: rgba(255, 255, 255, 0.04); color: var(--text-dim); }
.event-log-type.agent_spawn { background: rgba(249, 115, 22, 0.12); color: #f97316; }
.event-log-agent { color: var(--text-dim); white-space: nowrap; max-width: 60px; overflow: hidden; text-overflow: ellipsis; }
.event-log-detail { color: var(--text-primary); flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* ═══ COMPACTION MARKERS ═══ */
.compaction-marker { stroke: var(--amber); stroke-width: 1.5; stroke-dasharray: 5,3; cursor: pointer; }
.compaction-marker:hover { stroke-width: 2.5; filter: drop-shadow(0 0 4px var(--amber)); }
.compaction-label { font-size: 9px; fill: var(--amber); font-weight: 700; cursor: pointer; }
.session-end-marker { stroke: rgba(255,255,255,0.4); stroke-width: 1; }
.session-end-label { font-size: 9px; fill: var(--text-dim); }

/* ═══ HIGHLIGHT LINE ═══ */
.highlight-line { stroke: var(--accent); stroke-width: 2; pointer-events: none; }
.highlight-label { font-size: 9px; fill: var(--accent); font-weight: 700; pointer-events: none; }

/* ═══ CONTEXT EPOCH ═══ */
.context-epoch { cursor: pointer; transition: fill 0.15s; }
.context-epoch:hover { fill: rgba(234, 179, 8, 0.07) !important; }

/* ═══ PLAN CYCLES ═══ */
.plan-cycle-card {
  background: rgba(0,0,0,0.2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 12px;
  margin-bottom: 8px;
  cursor: pointer;
  transition: all 0.15s;
}

.plan-cycle-card:hover { border-color: var(--purple); background: rgba(167, 139, 250, 0.04); }
.plan-cycle-card.highlighted { border-color: var(--purple); background: rgba(167, 139, 250, 0.08); }

.plan-cycle-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}

.plan-cycle-num { font-size: 12px; font-weight: 700; color: var(--purple); }
.plan-write-dot { fill: var(--purple); cursor: pointer; }

/* ═══ CONTEXT TAB ═══ */
.context-section {
  border-bottom: 1px solid var(--border);
  padding-bottom: 8px;
  margin-bottom: 8px;
}
.context-section:last-child { border-bottom: none; margin-bottom: 0; }
.context-section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  cursor: pointer;
  user-select: none;
}
.context-section-header h3 {
  font-family: 'DM Sans', sans-serif;
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1.2px;
  color: var(--accent);
  margin: 0;
}
.context-section-header .ctx-meta {
  font-family: 'DM Mono', monospace;
  font-size: 9px;
  color: var(--text-dim);
}
.context-path {
  font-family: 'DM Mono', monospace;
  font-size: 10px;
  color: var(--text-dim);
  padding: 0 8px 4px;
}
.context-content {
  font-family: 'DM Mono', monospace;
  font-size: 11px;
  line-height: 1.5;
  white-space: pre-wrap;
  word-break: break-word;
  color: var(--text-primary);
  padding: 4px 8px;
}
.context-content.below-truncation { opacity: 0.5; }
.context-truncation-mark {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  margin: 4px 0;
  font-family: 'DM Mono', monospace;
  font-size: 10px;
  color: var(--amber);
  border-top: 1px dashed rgba(234, 179, 8, 0.4);
  border-bottom: 1px dashed rgba(234, 179, 8, 0.4);
  background: rgba(234, 179, 8, 0.04);
  letter-spacing: 0.3px;
}
.context-empty {
  color: var(--text-dim);
  font-size: 12px;
  text-align: center;
  padding: 32px 16px;
}
</style>
</head>
<body>
<div class="reconnect-banner" id="reconnect-banner">Disconnected — reconnecting...</div>
<div class="tooltip" id="tooltip" style="display:none"></div>

<div id="detail-drawer" class="detail-drawer">
  <div class="drawer-header">
    <h2 id="drawer-title">Agent Detail</h2>
    <button class="drawer-close" id="drawer-close">&times;</button>
  </div>
  <div class="drawer-body" id="drawer-body"></div>
</div>

<div id="app">
  <header>
    <h1>AI SCRY</h1>
    <div class="controls">
      <div class="session-controls">
        <div class="session-toggle">
          <button id="filter-active" class="active">Active</button>
          <button id="filter-all">All</button>
        </div>
        <select id="session-select"><option value="">No sessions</option></select>
      </div>
      <div class="status">
        <div class="dot" id="status-dot"></div>
        <span id="status-text">Connected</span>
      </div>
    </div>
  </header>

  <div id="stats-panel">
    <div class="stats-cards">
      <div class="stat-card">
        <div class="stat-card-accent"></div>
        <div class="stat-card-inner">
          <div>
            <div class="title">Tokens</div>
            <div class="value" id="val-tokens">0</div>
            <div class="secondary" id="sec-tokens">avg 0/agent</div>
          </div>
          <div class="sparkline"><svg id="spark-tokens"></svg></div>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-card-accent"></div>
        <div class="stat-card-inner">
          <div>
            <div class="title">Cost</div>
            <div class="value" id="val-cost">$0.00</div>
            <div class="secondary" id="sec-cost">avg $0.00/agent</div>
          </div>
          <div class="sparkline"><svg id="spark-cost"></svg></div>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-card-accent"></div>
        <div class="stat-card-inner">
          <div>
            <div class="title">Agents</div>
            <div class="value" id="val-agents">0</div>
            <div class="secondary" id="sec-agents">0 active</div>
          </div>
          <div class="sparkline"><svg id="spark-agents"></svg></div>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-card-accent"></div>
        <div class="stat-card-inner">
          <div>
            <div class="title">Duration</div>
            <div class="value" id="val-duration">0s</div>
            <div class="secondary" id="sec-duration">est. remaining: —</div>
          </div>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-card-accent"></div>
        <div class="stat-card-inner">
          <div>
            <div class="title">Efficiency</div>
            <div class="value" id="val-efficiency">—</div>
            <div class="secondary" id="sec-efficiency">&nbsp;</div>
            <div class="progress-bar"><div class="fill" id="efficiency-bar" style="width:0%"></div></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel" id="timeline-panel">
    <div class="panel-header" style="display:flex;align-items:center;justify-content:space-between">
      <span>Timeline</span>
      <span id="tool-legend" style="display:flex;gap:8px;font-size:9px;font-weight:400;letter-spacing:0"></span>
    </div>
    <div class="empty-state" id="timeline-empty">Waiting for events...</div>
    <svg id="timeline-svg"></svg>
  </div>

  <div class="panel" id="sankey-panel">
    <div class="panel-header" style="display:flex;align-items:center;justify-content:space-between">
      <span>Flow</span>
      <span id="sankey-metric-toggle" style="display:flex;gap:2px;font-size:9px"></span>
    </div>
    <div class="empty-state" id="sankey-empty">Waiting for events...</div>
    <svg id="sankey-svg"></svg>
  </div>

  <div id="sidebar-panel">
    <div class="sidebar-tabs">
      <div class="sidebar-tab active" data-tab="agents">Agents</div>
      <div class="sidebar-tab" data-tab="events">Events</div>
      <div class="sidebar-tab" data-tab="tasks">Tasks</div>
      <div class="sidebar-tab" data-tab="plan">Plan</div>
      <div class="sidebar-tab" data-tab="context">Context</div>
    </div>
    <div class="sidebar-content">
      <div class="sidebar-pane active" id="pane-agents">
        <div id="agent-cards-container"></div>
      </div>
      <div class="sidebar-pane" id="pane-events" style="display:none;flex-direction:column;height:100%">
        <div class="event-log-controls">
          <input type="text" id="event-filter-text" placeholder="Filter events...">
          <select id="event-filter-type">
            <option value="">All types</option>
            <option value="tool_start">tool_start</option>
            <option value="tool_end">tool_end</option>
            <option value="agent_complete">agent_complete</option>
            <option value="agent_spawn">agent_spawn</option>
            <option value="compaction">compaction</option>
            <option value="session_start">session_start</option>
            <option value="session_end">session_end</option>
          </select>
        </div>
        <ul class="event-log-list" id="event-log-list"></ul>
      </div>
      <div class="sidebar-pane" id="pane-tasks">
        <ul class="task-list" id="task-list"></ul>
      </div>
      <div class="sidebar-pane" id="pane-plan">
        <div class="plan-panel" id="plan-panel">
          <div class="plan-empty">No plan detected</div>
        </div>
      </div>
      <div class="sidebar-pane" id="pane-context">
        <div class="context-empty">Loading context...</div>
      </div>
    </div>
  </div>

  <div id="info-bar">
    <span id="info-events">0 events</span>
    <span class="info-badge plan-mode" id="info-plan-mode">PLAN MODE</span>
    <span class="info-badge tasks-count" id="info-tasks">0 tasks</span>
    <span class="info-badge compaction-count" id="info-compactions">0 compactions</span>
    <span class="info-badge compaction-count" id="info-context-cycles" style="display:none">0 contexts</span>
    <span class="info-badge error-count" id="info-errors">0 errors</span>
  </div>
</div>

<script>
const state = {
  events: [],
  agents: new Map(),
  toolCalls: [],
  selectedAgentId: null,
  paused: false,
  sessionStart: null,
  tokenHistory: [],
  costHistory: [],
  agentCountHistory: [],
  sortCol: 'agent',
  sortAsc: true,
  timelineCollapsed: new Set(),
  tasks: new Map(),
  // Multi-plan support
  planCycles: [],
  planMode: false,
  activeTab: 'agents',
  // Compaction tracking
  compactions: [],
  // Context cycles (bounded by session start + compactions + /clear)
  contextCycles: [],
  highlightedContextCycle: null,
  // Session end
  sessionEndTime: null,
  // Event log + timeline sync
  highlightTimestamp: null,
  highlightedEventId: null,
  sankeyMetric: 'tokens', // tokens | tools | equal
  // User prompts + agent stops (prompt-oriented Sankey)
  userPrompts: [],
  agentStops: [],
  highlightedPromptIndex: null,
  toolErrors: [],
  permissions: [],
  notifications: [],
};

let sessionFilter = 'active';
let sessionsList = [];

function relativeTime(ts) {
  const diff = Date.now() - ts;
  if (diff < 60_000) return 'just now';
  if (diff < 3_600_000) return `${Math.floor(diff / 60_000)}m ago`;
  if (diff < 86_400_000) return `${Math.floor(diff / 3_600_000)}h ago`;
  const d = new Date(ts);
  const mon = d.toLocaleString('en', { month: 'short' });
  const day = d.getDate();
  const time = d.toLocaleTimeString('en', { hour: 'numeric', minute: '2-digit' });
  return `${mon} ${day} ${time}`;
}

// --- Time formatting ---

function formatTime(ms, baseMs) {
  const sec = (ms - baseMs) / 1000;
  if (sec < 60) return sec.toFixed(1) + 's';
  if (sec < 3600) {
    const m = Math.floor(sec / 60);
    const s = Math.floor(sec % 60);
    return `${m}:${String(s).padStart(2, '0')}`;
  }
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = Math.floor(sec % 60);
  return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
}

function getTickInterval(rangeSeconds) {
  if (rangeSeconds < 60) return 5;
  if (rangeSeconds < 300) return 15;
  if (rangeSeconds < 3600) return 60;
  return Math.ceil(rangeSeconds / 10);
}

// --- Skill helper ---

function extractSkillName(params) {
  if (!params) return null;
  const m = String(params).match(/skill[=:]\s*["']?([^"'\s,]+)/i);
  return m ? m[1] : null;
}

// --- Event ingestion ---

function ingestEvent(evt) {
  state.events.push(evt);

  if (!state.sessionStart) state.sessionStart = evt.timestamp;

  // Task/Plan data ingestion
  if (evt.task_data) ingestTaskData(evt);
  if (evt.plan_data) ingestPlanData(evt);

  if (evt.event_type === 'compaction') {
    state.compactions.push({ timestamp: evt.timestamp, trigger: evt.trigger || 'auto' });
    buildContextCycles();
  }

  // /clear fires a new session_start with source='clear' — treat as context boundary
  if (evt.event_type === 'session_start' && evt.source === 'clear') {
    state.compactions.push({ timestamp: evt.timestamp, trigger: 'clear' });
    buildContextCycles();
  }

  if (evt.event_type === 'user_prompt') {
    state.userPrompts.push({
      timestamp: evt.timestamp,
      text: evt.prompt_text || '',
      agentId: evt.agent_id,
    });
  }

  if (evt.event_type === 'agent_stop') {
    state.agentStops.push({
      timestamp: evt.timestamp,
      agentId: evt.agent_id,
      stopHookActive: evt.stop_hook_active || false,
    });
  }

  if (evt.event_type === 'session_end') {
    state.sessionEndTime = evt.timestamp;
    buildContextCycles();
  }

  if (evt.event_type === 'session_start') {
    if (!state.agents.has(evt.agent_id || 'ag_main')) {
      state.agents.set(evt.agent_id || 'ag_main', {
        id: evt.agent_id || 'ag_main',
        parentId: null,
        label: 'main',
        task: 'Root session',
        tags: [],
        model: evt.model || null,
        spawnTime: evt.timestamp,
        endTime: null,
        tokensIn: 0,
        tokensOut: 0,
        durationMs: 0,
        status: 'running',
        tools: [],
        contributesTo: [],
        transcriptPath: evt.transcript_path || null,
      });
    }
    buildContextCycles();
    return;
  }

  if (evt.event_type === 'agent_start') {
    const agentId = evt.agent_id || 'ag_unknown';
    if (!state.agents.has(agentId)) {
      state.agents.set(agentId, {
        id: agentId,
        parentId: null,
        label: evt.agent_type || 'unknown',
        task: '',
        tags: [],
        model: null,
        spawnTime: evt.timestamp,
        endTime: null,
        tokensIn: 0, tokensOut: 0, durationMs: 0,
        status: 'running',
        tools: [],
        contributesTo: [],
        agentType: evt.agent_type || null,
      });
    }
    return;
  }

  if (evt.event_type === 'agent_spawn' || (evt.event_type === 'tool_start' && evt.spawns_agent_id)) {
    const agentId = evt.spawns_agent_id || evt.agent_id;
    const isSpawn = !!evt.spawns_agent_id;
    const parentId = isSpawn ? (evt.agent_id || null) : (evt.parent_agent_id || null);
    const label = evt.agent_spawn_label || evt.agent_label || null;
    const task = evt.agent_spawn_task || evt.task_description || '';
    const model = evt.agent_spawn_model || evt.model || null;
    const tags = evt.task_tags || [];
    if (state.agents.has(agentId)) {
      // Enrich existing agent (created earlier by agent_start) with spawn details
      const agent = state.agents.get(agentId);
      if (!agent.parentId && parentId) agent.parentId = parentId;
      if (label && agent.label === 'unknown') agent.label = label;
      if (task && !agent.task) agent.task = task;
      if (model && !agent.model) agent.model = model;
      if (tags.length && !agent.tags.length) agent.tags = tags;
    } else {
      state.agents.set(agentId, {
        id: agentId,
        parentId,
        label: label || 'unknown',
        task,
        tags,
        model,
        spawnTime: evt.timestamp,
        endTime: null,
        tokensIn: 0,
        tokensOut: 0,
        durationMs: 0,
        status: 'running',
        tools: [],
        contributesTo: [],
      });
    }
  }

  if (evt.event_type === 'tool_start') {
    const agentId = evt.agent_id || 'ag_main';
    if (!state.agents.has(agentId)) {
      state.agents.set(agentId, {
        id: agentId, parentId: null, label: evt.agent_label || 'main',
        task: '', tags: [], model: null, spawnTime: evt.timestamp, endTime: null,
        tokensIn: 0, tokensOut: 0, durationMs: 0, status: 'running',
        tools: [], contributesTo: [],
      });
    }
    state.toolCalls.push({
      id: evt.id,
      agentId,
      toolName: evt.tool_name,
      startTime: evt.timestamp,
      endTime: null,
      params: evt.tool_params_summary || '',
      toolUseId: evt.tool_use_id || null,
      cwd: evt.cwd || null,
    });
  }

  if (evt.event_type === 'tool_end') {
    const tc = [...state.toolCalls].reverse().find(
      t => t.agentId === (evt.agent_id || 'ag_main') && t.toolName === evt.tool_name && !t.endTime
    );
    if (tc) {
      tc.endTime = evt.timestamp;
      tc.tokensIn = evt.tokens_in || 0;
      tc.tokensOut = evt.tokens_out || 0;
      tc.hasError = !!evt.has_error;
      tc.responseSummary = evt.tool_response_summary || '';
    }
  }

  if (evt.event_type === 'agent_complete') {
    const agent = state.agents.get(evt.agent_id);
    if (agent) {
      agent.endTime = evt.timestamp;
      agent.tokensIn = evt.tokens_in || 0;
      agent.tokensOut = evt.tokens_out || 0;
      agent.durationMs = evt.duration_ms || (evt.timestamp - agent.spawnTime);
      agent.status = evt.status || 'success';
      agent.contributesTo = evt.contributes_to || [];
      agent.tags = evt.task_tags || agent.tags;
      if (evt.model && !agent.model) agent.model = evt.model;
      if (!agent.parentId && evt.parent_agent_id) agent.parentId = evt.parent_agent_id;
      if (evt.transcript_path) agent.transcriptPath = evt.transcript_path;
    }
  }

  if (evt.event_type === 'attribution') {
    const targetAgentId = evt.agent_id;
    const ids = new Set(evt.tool_use_ids || []);
    if (ids.size && state.agents.has(targetAgentId)) {
      for (const tc of state.toolCalls) {
        if (tc.toolUseId && ids.has(tc.toolUseId)) {
          tc.agentId = targetAgentId;
        }
      }
    }
    return;
  }

  if (evt.event_type === 'tool_error') {
    state.toolErrors.push({
      id: evt.id,
      toolName: evt.tool_name,
      toolUseId: evt.tool_use_id || null,
      timestamp: evt.timestamp,
      error: evt.error || '',
      agentId: evt.agent_id || 'ag_main',
    });
  }

  if (evt.event_type === 'permission_request') {
    state.permissions.push({ timestamp: evt.timestamp, toolName: evt.tool_name });
  }

  if (evt.event_type === 'notification') {
    state.notifications.push({ timestamp: evt.timestamp, id: evt.id });
  }

  updateHistories();
}

function ingestTaskData(evt) {
  const td = evt.task_data;
  if (!td) return;
  if (td.task_type === 'task_create') {
    const id = String(state.tasks.size + 1);
    state.tasks.set(id, {
      id,
      subject: td.subject,
      description: td.description || '',
      activeForm: td.activeForm || '',
      status: 'pending',
      owner: null,
      agentId: evt.agent_id || null,
      createdAt: evt.timestamp,
    });
  } else if (td.task_type === 'task_update') {
    const task = state.tasks.get(td.taskId);
    if (task) {
      if (td.status) task.status = td.status;
      if (td.owner) task.owner = td.owner;
      if (td.subject) task.subject = td.subject;
    }
  } else if (td.task_type === 'task_list' && Array.isArray(td.tasks)) {
    for (const t of td.tasks) {
      const id = t.id || String(t.index);
      if (state.tasks.has(id)) {
        const existing = state.tasks.get(id);
        if (t.status) existing.status = t.status;
        if (t.subject) existing.subject = t.subject;
        if (t.owner) existing.owner = t.owner;
      } else {
        state.tasks.set(id, {
          id, subject: t.subject || '', description: t.description || '',
          activeForm: '', status: t.status || 'pending',
          owner: t.owner || null, agentId: null, createdAt: evt.timestamp,
        });
      }
    }
  } else if (td.task_type === 'task_get' && td.task) {
    const t = td.task;
    const id = t.id || t.taskId;
    if (id && state.tasks.has(id)) {
      const existing = state.tasks.get(id);
      if (t.status) existing.status = t.status;
      if (t.subject) existing.subject = t.subject;
    }
  }
}

function ingestPlanData(evt) {
  const pd = evt.plan_data;
  if (!pd) return;
  if (pd.plan_event === 'enter_plan_mode') {
    state.planMode = true;
    state.planCycles.push({ startTime: evt.timestamp, endTime: null, content: null, active: true, writeTime: null });
  } else if (pd.plan_event === 'exit_plan_mode') {
    state.planMode = false;
    const cycle = [...state.planCycles].reverse().find(c => c.active);
    if (cycle) { cycle.endTime = evt.timestamp; cycle.active = false; }
  } else if (pd.plan_event === 'plan_write') {
    const cycle = [...state.planCycles].reverse().find(c => c.active) || state.planCycles[state.planCycles.length - 1];
    if (cycle) {
      cycle.content = { filePath: pd.file_path, preview: pd.content_preview };
      cycle.writeTime = evt.timestamp;
    }
  }
}

function buildContextCycles() {
  state.contextCycles = [];
  const boundaries = [state.sessionStart || 0];
  state.compactions.forEach(c => boundaries.push(c.timestamp));
  for (let i = 0; i < boundaries.length; i++) {
    state.contextCycles.push({
      startTime: boundaries[i],
      endTime: i < boundaries.length - 1 ? boundaries[i + 1] : (state.sessionEndTime || null),
      index: i,
      trigger: i === 0 ? 'session_start' : (state.compactions[i - 1]?.trigger || 'auto'),
    });
  }
}

function updateHistories() {
  const agents = [...state.agents.values()];
  const totalTokens = agents.reduce((s, a) => s + a.tokensIn + a.tokensOut, 0);
  const totalCost = agents.reduce((s, a) => s + (a.tokensIn * 15 / 1_000_000) + (a.tokensOut * 75 / 1_000_000), 0);

  state.tokenHistory.push(totalTokens);
  if (state.tokenHistory.length > 30) state.tokenHistory.shift();

  state.costHistory.push(totalCost);
  if (state.costHistory.length > 30) state.costHistory.shift();

  state.agentCountHistory.push(agents.filter(a => a.status === 'running').length);
  if (state.agentCountHistory.length > 30) state.agentCountHistory.shift();
}

// --- SSE connection ---

let evtSource = null;
let reconnectTimer = null;
let lastEventAt = 0;
let idleTimer = null;
const IDLE_THRESHOLD_MS = 15_000;

function finalizeRunningAgents() {
  const now = Date.now();
  let changed = false;
  for (const agent of state.agents.values()) {
    if (agent.status === 'running') {
      agent.endTime = agent.endTime || lastEventAt || now;
      agent.durationMs = agent.endTime - agent.spawnTime;
      agent.status = 'success';
      changed = true;
    }
  }
  for (const tc of state.toolCalls) {
    if (!tc.endTime) { tc.endTime = lastEventAt || now; changed = true; }
  }
  if (changed) render();
}

function resetIdleTimer() {
  lastEventAt = Date.now();
  if (idleTimer) clearTimeout(idleTimer);
  idleTimer = setTimeout(finalizeRunningAgents, IDLE_THRESHOLD_MS);
}

function connectSSE() {
  if (evtSource) evtSource.close();
  evtSource = new EventSource('/api/events');

  evtSource.addEventListener('message', (e) => {
    let evt;
    try { evt = JSON.parse(e.data); } catch { return; }
    if (evt.event_type === 'session_start' && sessionFilter === 'active') {
      loadSessions().then(() => {
        const sel = document.getElementById('session-select');
        if (sel.options.length > 0) {
          sel.selectedIndex = 0;
          loadSession(sel.value);
        }
      });
      return;
    }
    ingestEvent(evt);
    resetIdleTimer();
    if (!state.paused) render();
  });

  evtSource.onopen = () => {
    document.getElementById('reconnect-banner').style.display = 'none';
    document.getElementById('status-dot').classList.remove('disconnected');
    document.getElementById('status-text').textContent = 'Connected';
    if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
  };

  evtSource.onerror = () => {
    document.getElementById('reconnect-banner').style.display = 'block';
    document.getElementById('status-dot').classList.add('disconnected');
    document.getElementById('status-text').textContent = 'Disconnected';
    evtSource.close();
    finalizeRunningAgents();
    if (!reconnectTimer) {
      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        connectSSE();
      }, 3000);
    }
  };
}

async function loadSession(sessionId) {
  try {
  const url = sessionId ? `/api/session?id=${sessionId}` : '/api/session';
  const res = await fetch(url);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const events = await res.json();
  state.events = [];
  state.agents.clear();
  state.toolCalls = [];
  state.sessionStart = null;
  state.tokenHistory = [];
  state.costHistory = [];
  state.agentCountHistory = [];
  state.tasks.clear();
  state.planCycles = [];
  state.planMode = false;
  state.compactions = [];
  state.contextCycles = [];
  state.highlightedContextCycle = null;
  state.sessionEndTime = null;
  state.highlightTimestamp = null;
  state.highlightedEventId = null;
  state.userPrompts = [];
  state.agentStops = [];
  state.highlightedPromptIndex = null;
  state.toolErrors = [];
  state.permissions = [];
  state.notifications = [];
  contextLoaded = false;
  events.forEach(e => ingestEvent(e));
  const lastTs = events.length ? events[events.length - 1].timestamp : 0;
  if (lastTs && (Date.now() - lastTs > IDLE_THRESHOLD_MS)) finalizeRunningAgents();
  render();
  } catch (err) {
    console.warn('Failed to load session:', err);
  }
}

async function loadSessions() {
  try {
    const res = await fetch('/api/sessions');
    sessionsList = await res.json();
    renderSessionDropdown();
  } catch {}
}

function renderSessionDropdown() {
  const sel = document.getElementById('session-select');
  const filtered = sessionFilter === 'active'
    ? sessionsList.filter(s => s.active)
    : sessionsList;
  sel.innerHTML = '';
  if (filtered.length === 0) {
    sel.innerHTML = '<option value="">No sessions</option>';
    return;
  }
  filtered.forEach(s => {
    const opt = document.createElement('option');
    opt.value = s.id;
    const name = s.project || s.id.slice(0, 12);
    opt.textContent = `${name} · ${relativeTime(s.startTime)}`;
    sel.appendChild(opt);
  });
}

// --- Render orchestration ---

function render() {
  renderTimeline();
  renderSankey();
  renderStats();
  renderSidebar();
  renderInfoBar();
  renderEventLog();
}

// --- Timeline panel ---

function renderTimeline() {
  const container = document.getElementById('timeline-panel');
  const svg = d3.select('#timeline-svg');
  const emptyEl = document.getElementById('timeline-empty');

  if (state.agents.size === 0) {
    emptyEl.style.display = 'flex';
    svg.selectAll('*').remove();
    return;
  }
  emptyEl.style.display = 'none';

  const headerH = container.querySelector('.panel-header').offsetHeight;
  const width = container.clientWidth;
  const margin = { top: 10, right: 20, bottom: 28, left: 140 };

  svg.selectAll('*').remove();

  const agents = buildAgentTree();

  if (agents.length > 20 && state.timelineCollapsed.size === 0) {
    agents.filter(a => !a.parentId || !state.agents.has(a.parentId)).forEach(a => {
      const hasChildren = agents.some(c => c.parentId === a.id);
      if (hasChildren) state.timelineCollapsed.add(a.id);
    });
  }

  const visibleAgents = agents.filter(a => isVisible(a.id));
  const now = Date.now();

  const xMin = d3.min(visibleAgents, a => a.spawnTime) || now - 10000;
  const xMax = d3.max(visibleAgents, a => a.endTime || now) || now;
  const rangeSeconds = (xMax - xMin) / 1000;

  const x = d3.scaleLinear()
    .domain([xMin, xMax + (xMax - xMin) * 0.05])
    .range([margin.left, width - margin.right]);

  const rowH = 38;
  const maxH = Math.min(visibleAgents.length * rowH + margin.top + margin.bottom, window.innerHeight * 0.5);
  const contentH = margin.top + visibleAgents.length * rowH + margin.bottom;
  const height = Math.max(contentH, 100);
  svg.attr('viewBox', `0 0 ${width} ${height}`);
  svg.style('height', `${Math.min(height, maxH)}px`);
  const y = (i) => margin.top + i * rowH;

  const g = svg.append('g');

  const agentColors = {
    main: '#9ca3af', Explore: '#60a5fa', Plan: '#a78bfa',
    Bash: '#22c55e', 'general-purpose': '#eab308',
  };

  const toolColors = {
    Read: '#60a5fa', Write: '#10b981', Edit: '#eab308', Glob: '#6366f1',
    Grep: '#8b5cf6', Bash: '#22c55e', Task: '#f97316', NotebookEdit: '#fb923c',
    WebFetch: '#22d3ee', WebSearch: '#2dd4bf', Skill: '#e879f9',
    EnterPlanMode: '#a78bfa', ExitPlanMode: '#a78bfa',
    TaskCreate: '#6366f1', TaskUpdate: '#6366f1', TaskList: '#6366f1',
  };
  const defaultToolColor = '#94a3b8';

  // Context cycle epoch bands — alternating tint per cycle
  if (state.contextCycles.length > 1) {
    state.contextCycles.forEach((cycle, i) => {
      const epochStart = x(cycle.startTime);
      const epochEndTs = cycle.endTime || (xMax + (xMax - xMin) * 0.05);
      const epochEnd = x(epochEndTs);
      const isHighlighted = state.highlightedContextCycle === i;
      g.append('rect')
        .attr('class', 'context-epoch')
        .attr('x', epochStart).attr('y', 0)
        .attr('width', Math.max(epochEnd - epochStart, 1)).attr('height', height - margin.bottom)
        .attr('fill', isHighlighted
          ? 'rgba(234, 179, 8, 0.08)'
          : (i % 2 === 1 ? 'rgba(234, 179, 8, 0.04)' : 'rgba(234, 179, 8, 0.015)'))
        .style('cursor', 'pointer')
        .on('click', () => highlightContextCycle(i))
        .on('mouseenter', (e) => showTooltip(e, `<span class="label" style="color:var(--amber)">CTX ${i + 1}</span><br>Trigger: ${esc(cycle.trigger)}`))
        .on('mouseleave', hideTooltip);
    });
  }

  // Multi-plan mode regions (overlays within context cycles)
  state.planCycles.forEach((cycle, i) => {
    const pStart = x(cycle.startTime);
    const pEnd = x(cycle.endTime || now);
    g.append('rect')
      .attr('class', 'plan-mode-region')
      .attr('x', pStart).attr('y', 0)
      .attr('width', Math.max(pEnd - pStart, 2)).attr('height', height - margin.bottom)
      .attr('rx', 4)
      .attr('fill', 'rgba(167, 139, 250, 0.06)')
      .attr('stroke', 'rgba(167, 139, 250, 0.2)')
      .attr('stroke-dasharray', '4,4');
    g.append('text')
      .attr('class', 'plan-mode-label')
      .attr('x', pStart + 6).attr('y', 8)
      .attr('dy', '0.7em')
      .text(`PLAN ${i + 1}`);
    // Plan write dot
    if (cycle.writeTime) {
      g.append('circle')
        .attr('class', 'plan-write-dot')
        .attr('cx', x(cycle.writeTime)).attr('cy', 14)
        .attr('r', 4)
        .on('mouseenter', (e) => showTooltip(e, `<span class="label">Plan Write</span><br>${esc(cycle.content?.filePath || 'unknown')}`))
        .on('mouseleave', hideTooltip);
    }
  });

  visibleAgents.forEach((agent, i) => {
    const color = agentColors[agent.label] || '#9ca3af';
    const barY = y(i) + 3;
    const barH = rowH - 6;
    const startX = x(agent.spawnTime);
    const endX = x(agent.endTime || now);

    const depth = getDepth(agent.id);
    const indent = depth * 12;

    if (agent.parentId) {
      const parentIdx = visibleAgents.findIndex(a => a.id === agent.parentId);
      if (parentIdx >= 0) {
        g.append('line')
          .attr('class', 'connector-line')
          .attr('x1', startX).attr('y1', y(parentIdx) + rowH / 2)
          .attr('x2', startX).attr('y2', barY + barH / 2);
      }
    }

    const isDimmed = (state.selectedAgentId && state.selectedAgentId !== agent.id) ||
      (state.highlightedContextCycle !== null && !isAgentInContextCycle(agent, state.highlightedContextCycle));
    g.append('rect')
      .attr('class', `timeline-bar ${isDimmed ? 'dimmed' : ''}`)
      .attr('x', startX).attr('y', barY)
      .attr('width', Math.max(endX - startX, 2)).attr('height', barH)
      .attr('rx', 4)
      .attr('fill', color).attr('opacity', 0.1)
      .on('click', () => selectAgent(agent.id))
      .on('mouseenter', (e) => showTooltip(e, agentTooltipHtml(agent)))
      .on('mouseleave', hideTooltip);

    g.append('line')
      .attr('x1', startX).attr('y1', barY + barH / 2)
      .attr('x2', endX).attr('y2', barY + barH / 2)
      .attr('stroke', color).attr('stroke-opacity', 0.12).attr('stroke-width', 1);

    const agentTools = state.toolCalls.filter(t => t.agentId === agent.id);
    agentTools.forEach(tc => {
      // Skip Skill calls — rendered as diamonds below
      if (tc.toolName === 'Skill') return;
      const tcStart = x(tc.startTime);
      const tcEnd = x(tc.endTime || now);
      const tcW = Math.max(tcEnd - tcStart, 3);
      const tcColor = tc.hasError ? '#f43f5e' : (toolColors[tc.toolName] || defaultToolColor);
      g.append('rect')
        .attr('class', `tool-segment ${isDimmed ? 'dimmed' : ''}`)
        .attr('x', tcStart).attr('y', barY + 1)
        .attr('width', tcW).attr('height', barH - 2)
        .attr('rx', 3)
        .attr('fill', tcColor).attr('opacity', tc.hasError ? 0.95 : 0.8)
        .on('mouseenter', (e) => {
          let tip = `<span class="label">${esc(tc.toolName)}</span>`;
          if (tc.hasError) tip += ' <span style="color:var(--red)">ERROR</span>';
          tip += `<br><span class="dim">${esc(tc.params)}</span>`;
          if (tc.responseSummary) tip += `<br><span class="dim">${esc(tc.responseSummary)}</span>`;
          if (tc.cwd && tc.toolName === 'Bash') tip += `<br><span class="dim">cwd: ${esc(tc.cwd)}</span>`;
          showTooltip(e, tip);
        })
        .on('mouseleave', hideTooltip);

      if (tcW > 28) {
        g.append('text')
          .attr('class', 'tool-label')
          .attr('x', tcStart + 4).attr('y', barY + barH / 2 + 1)
          .attr('dy', '0.3em')
          .attr('data-tcw', tcW)
          .text(tc.toolName.slice(0, Math.floor(tcW / 6)));
      }
    });

    // Skill diamond markers
    const skillCalls = agentTools.filter(tc => tc.toolName === 'Skill');
    skillCalls.forEach(tc => {
      const sx = x(tc.startTime);
      const sy = barY + barH / 2;
      const d = 6;
      const skillName = extractSkillName(tc.params) || 'Skill';
      g.append('path')
        .attr('class', `skill-marker ${isDimmed ? 'dimmed' : ''}`)
        .attr('d', `M${sx},${sy - d} L${sx + d},${sy} L${sx},${sy + d} L${sx - d},${sy} Z`)
        .attr('fill', '#e879f9').attr('opacity', 0.9)
        .attr('stroke', '#c026d3').attr('stroke-width', 1)
        .on('mouseenter', (e) => showTooltip(e, `<span class="label" style="color:#e879f9">Skill</span><br>${esc(skillName)}`))
        .on('mouseleave', hideTooltip);
    });

    if (!agent.endTime) {
      g.append('rect')
        .attr('class', 'pulse-cap')
        .attr('x', endX - 3).attr('y', barY)
        .attr('width', 3).attr('height', barH)
        .attr('fill', color).attr('opacity', 0.8)
        .attr('rx', 1);
    }

    const hasChildren = [...state.agents.values()].some(a => a.parentId === agent.id);
    const collapsed = state.timelineCollapsed.has(agent.id);
    const prefix = hasChildren ? (collapsed ? '+ ' : '- ') : '  ';

    g.append('text')
      .attr('x', margin.left - 8 + indent)
      .attr('y', barY + barH / 2 + 1)
      .attr('text-anchor', 'end')
      .attr('fill', color)
      .attr('font-size', '11px')
      .attr('cursor', hasChildren ? 'pointer' : 'default')
      .text(prefix + agent.label + (agent.id !== 'ag_main' ? ' ' + agent.id.slice(-6) : ''))
      .on('click', () => {
        if (hasChildren) {
          if (collapsed) state.timelineCollapsed.delete(agent.id);
          else state.timelineCollapsed.add(agent.id);
          render();
        }
      });
  });

  // Compaction markers
  state.compactions.forEach((c, i) => {
    const cx = x(c.timestamp);
    g.append('line')
      .attr('class', 'compaction-marker')
      .attr('x1', cx).attr('y1', 0).attr('x2', cx).attr('y2', height - margin.bottom)
      .on('click', () => openCompactionDrawer(i, c))
      .on('mouseenter', (e) => showTooltip(e, `<span class="label" style="color:var(--amber)">Compaction C${i + 1}</span><br>Trigger: ${esc(c.trigger)}<br>${formatTime(c.timestamp, xMin)}`))
      .on('mouseleave', hideTooltip);
    g.append('text')
      .attr('class', 'compaction-label')
      .attr('x', cx + 4).attr('y', height - margin.bottom - 4)
      .text(`C${i + 1}`)
      .style('cursor', 'pointer')
      .on('click', () => openCompactionDrawer(i, c));
  });

  // Session end marker
  if (state.sessionEndTime) {
    const sex = x(state.sessionEndTime);
    g.append('line')
      .attr('class', 'session-end-marker')
      .attr('x1', sex).attr('y1', 0).attr('x2', sex).attr('y2', height - margin.bottom);
    g.append('text')
      .attr('class', 'session-end-label')
      .attr('x', sex + 4).attr('y', height - margin.bottom - 4)
      .text('END');
  }

  // Highlight line (event sync)
  if (state.highlightTimestamp) {
    const hlx = x(state.highlightTimestamp);
    g.append('line')
      .attr('class', 'highlight-line')
      .attr('x1', hlx).attr('y1', 0).attr('x2', hlx).attr('y2', height - margin.bottom);
    g.append('text')
      .attr('class', 'highlight-label')
      .attr('x', hlx + 4).attr('y', 14)
      .text(formatTime(state.highlightTimestamp, xMin));
  }

  // Tool legend
  const usedTools = new Set(state.toolCalls.map(t => t.toolName));
  const legend = document.getElementById('tool-legend');
  legend.innerHTML = [...usedTools].filter(n => !['EnterPlanMode','ExitPlanMode','TaskCreate','TaskUpdate','TaskList','TaskGet'].includes(n)).slice(0, 8).map(name => {
    const c = toolColors[name] || defaultToolColor;
    const short = name.length > 10 ? name.slice(0, 9) + '\u2026' : name;
    return `<span style="display:flex;align-items:center;gap:3px" title="${esc(name)}"><span style="width:7px;height:7px;border-radius:2px;background:${c};display:inline-block;flex-shrink:0"></span>${esc(short)}</span>`;
  }).join('');

  // X-axis with smart formatting
  const tickInterval = getTickInterval(rangeSeconds);
  const xAxis = d3.axisBottom(x)
    .tickValues(d3.range(xMin, xMax + tickInterval * 1000, tickInterval * 1000))
    .tickFormat(d => formatTime(d, xMin));

  svg.append('g')
    .attr('class', 'x-axis')
    .attr('transform', `translate(0,${height - margin.bottom})`)
    .call(xAxis)
    .selectAll('text').attr('fill', '#555').attr('font-size', '9px');

  svg.selectAll('.domain, .tick line').attr('stroke', '#222');

  // Hover reference line
  const hoverG = svg.append('g').style('display', 'none');
  hoverG.append('line').attr('class', 'hover-line').attr('y1', 0).attr('y2', height - margin.bottom);
  hoverG.append('text').attr('class', 'hover-label').attr('y', -4);

  svg.on('mousemove', (e) => {
    const [mx] = d3.pointer(e);
    if (mx < margin.left || mx > width - margin.right) {
      hoverG.style('display', 'none');
      return;
    }
    hoverG.style('display', null);
    hoverG.select('line').attr('x1', mx).attr('x2', mx);
    const t = x.invert(mx);
    hoverG.select('text').attr('x', mx + 4).text(formatTime(t, xMin));
  }).on('mouseleave', () => hoverG.style('display', 'none'));

  // Zoom
  const zoom = d3.zoom()
    .scaleExtent([0.5, 50])
    .on('zoom', (event) => {
      const newX = event.transform.rescaleX(x);
      g.selectAll('.timeline-bar').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const ow = parseFloat(el.attr('data-ow'));
        el.attr('x', newX(ox)).attr('width', Math.max(newX(ox + ow) - newX(ox), 2));
      });
      g.selectAll('.tool-segment').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const ow = parseFloat(el.attr('data-ow'));
        el.attr('x', newX(ox)).attr('width', Math.max(newX(ox + ow) - newX(ox), 3));
      });
      g.selectAll('.tool-label').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const ow = parseFloat(el.attr('data-ow'));
        const newW = newX(ox + ow) - newX(ox);
        el.attr('x', newX(ox) + 4).attr('visibility', newW > 28 ? 'visible' : 'hidden');
        el.text(el.attr('data-name').slice(0, Math.floor(newW / 6)));
      });
      g.selectAll('.connector-line').each(function() {
        const el = d3.select(this);
        el.attr('x1', newX(parseFloat(el.attr('data-ox')))).attr('x2', newX(parseFloat(el.attr('data-ox'))));
      });
      g.selectAll('.pulse-cap').each(function() {
        const el = d3.select(this);
        el.attr('x', newX(parseFloat(el.attr('data-ox'))) - 1.5);
      });
      g.selectAll('.plan-mode-region').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const ow = parseFloat(el.attr('data-ow'));
        el.attr('x', newX(ox)).attr('width', Math.max(newX(ox + ow) - newX(ox), 2));
      });
      g.selectAll('.plan-mode-label').each(function() {
        const el = d3.select(this);
        el.attr('x', newX(parseFloat(el.attr('data-ox'))) + 6);
      });
      g.selectAll('.compaction-marker').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        el.attr('x1', newX(ox)).attr('x2', newX(ox));
      });
      g.selectAll('.compaction-label').each(function() {
        const el = d3.select(this);
        el.attr('x', newX(parseFloat(el.attr('data-ox'))) + 4);
      });
      g.selectAll('.session-end-marker').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        el.attr('x1', newX(ox)).attr('x2', newX(ox));
      });
      g.selectAll('.session-end-label').each(function() {
        const el = d3.select(this);
        el.attr('x', newX(parseFloat(el.attr('data-ox'))) + 4);
      });
      g.selectAll('.highlight-line').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        el.attr('x1', newX(ox)).attr('x2', newX(ox));
      });
      g.selectAll('.highlight-label').each(function() {
        const el = d3.select(this);
        el.attr('x', newX(parseFloat(el.attr('data-ox'))) + 4);
      });
      g.selectAll('.plan-write-dot').each(function() {
        const el = d3.select(this);
        el.attr('cx', newX(parseFloat(el.attr('data-ox'))));
      });
      g.selectAll('.context-epoch').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const ow = parseFloat(el.attr('data-ow'));
        el.attr('x', newX(ox)).attr('width', Math.max(newX(ox + ow) - newX(ox), 1));
      });
      g.selectAll('.skill-marker').each(function() {
        const el = d3.select(this);
        const ox = parseFloat(el.attr('data-ox'));
        const cy = parseFloat(el.attr('data-cy'));
        const sx = newX(ox);
        const d = 6;
        el.attr('d', `M${sx},${cy - d} L${sx + d},${cy} L${sx},${cy + d} L${sx - d},${cy} Z`);
      });
      svg.select('.x-axis').call(d3.axisBottom(newX).ticks(6).tickFormat(d => formatTime(d, xMin)));
      hoverG.style('display', 'none');
    });

  // Store original values for zoom
  g.selectAll('.timeline-bar').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x'))));
    el.attr('data-ow', x.invert(parseFloat(el.attr('x')) + parseFloat(el.attr('width'))) - x.invert(parseFloat(el.attr('x'))));
  });
  g.selectAll('.tool-segment').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x'))));
    el.attr('data-ow', x.invert(parseFloat(el.attr('x')) + parseFloat(el.attr('width'))) - x.invert(parseFloat(el.attr('x'))));
  });
  g.selectAll('.tool-label').each(function() {
    const el = d3.select(this);
    const lx = parseFloat(el.attr('x')) - 4;
    const tcw = parseFloat(el.attr('data-tcw'));
    el.attr('data-ox', x.invert(lx));
    el.attr('data-ow', x.invert(lx + tcw) - x.invert(lx));
    el.attr('data-name', el.text());
  });
  g.selectAll('.connector-line').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x1'))));
  });
  g.selectAll('.pulse-cap').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x')) + 1.5));
  });
  g.selectAll('.plan-mode-region').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x'))));
    el.attr('data-ow', x.invert(parseFloat(el.attr('x')) + parseFloat(el.attr('width'))) - x.invert(parseFloat(el.attr('x'))));
  });
  g.selectAll('.plan-mode-label').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x')) - 6));
  });
  g.selectAll('.compaction-marker').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x1'))));
  });
  g.selectAll('.compaction-label').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x')) - 4));
  });
  g.selectAll('.session-end-marker').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x1'))));
  });
  g.selectAll('.session-end-label').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x')) - 4));
  });
  g.selectAll('.highlight-line').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x1'))));
  });
  g.selectAll('.highlight-label').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x')) - 4));
  });
  g.selectAll('.plan-write-dot').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('cx'))));
  });
  g.selectAll('.context-epoch').each(function() {
    const el = d3.select(this);
    el.attr('data-ox', x.invert(parseFloat(el.attr('x'))));
    el.attr('data-ow', x.invert(parseFloat(el.attr('x')) + parseFloat(el.attr('width'))) - x.invert(parseFloat(el.attr('x'))));
  });
  g.selectAll('.skill-marker').each(function() {
    const el = d3.select(this);
    const dAttr = el.attr('d');
    const match = dAttr.match(/^M([\d.]+),([\d.]+)/);
    if (match) {
      const cx = parseFloat(match[1]);
      const cy = parseFloat(match[2]) + 6;
      el.attr('data-ox', x.invert(cx));
      el.attr('data-cy', cy);
    }
  });

  svg.call(zoom);
}

function buildAgentTree() {
  const agents = [...state.agents.values()];
  if (agents.length === 0) return [];
  const roots = agents.filter(a => !a.parentId || !state.agents.has(a.parentId));
  const result = [];
  function walk(agent) {
    result.push(agent);
    agents.filter(a => a.parentId === agent.id).sort((a, b) => a.spawnTime - b.spawnTime).forEach(walk);
  }
  roots.sort((a, b) => a.spawnTime - b.spawnTime);
  roots.forEach(walk);
  return result;
}

function isVisible(agentId) {
  const agent = state.agents.get(agentId);
  if (!agent) return false;
  let current = agent;
  while (current.parentId && state.agents.has(current.parentId)) {
    if (state.timelineCollapsed.has(current.parentId)) return false;
    current = state.agents.get(current.parentId);
  }
  return true;
}

function getDepth(agentId) {
  let depth = 0;
  let agent = state.agents.get(agentId);
  while (agent && agent.parentId && state.agents.has(agent.parentId)) {
    depth++;
    agent = state.agents.get(agent.parentId);
  }
  return depth;
}

function agentTooltipHtml(a) {
  const tokens = a.tokensIn + a.tokensOut;
  const dur = a.endTime ? ((a.endTime - a.spawnTime) / 1000).toFixed(1) + 's' : 'running';
  let tip = `<span class="label">${esc(a.label)}</span> ${esc(a.id.slice(-8))}`;
  if (a.model) tip += ` <span class="dim">[${esc(a.model)}]</span>`;
  tip += '<br>';
  if (a.task) tip += `<span class="dim">${esc(a.task.slice(0, 120))}</span><br>`;
  tip += `Tokens: ${tokens.toLocaleString()} · Duration: ${dur}<br>Status: ${esc(a.status)}`;
  // Task associations
  const agentTasks = [...state.tasks.values()].filter(t =>
    (t.owner && a.id.includes(t.owner)) || (a.task && t.subject && fuzzyMatch(a.task, t.subject))
  );
  if (agentTasks.length > 0) {
    tip += `<br><span class="dim">Tasks: ${agentTasks.map(t => esc(t.subject)).join(', ')}</span>`;
  }
  return tip;
}

function nodeTooltipHtml(d) {
  if (d.column === 0) {
    if (d.isPromptSource) {
      // Prompt source node
      const pi = d.promptIndex;
      let tip = `<span class="label">"${esc(d.promptText ? d.promptText.slice(0, 60) : d.name)}${d.promptText && d.promptText.length > 60 ? '...' : ''}"</span>`;
      tip += `<br><span class="dim">Turn ${pi + 1} · CTX ${(d.cycleIndex || 0) + 1}</span>`;
      // Count sub-agents and main tools for this prompt
      const nextTime = state.userPrompts[pi + 1]?.timestamp || state.sessionEndTime || Date.now();
      const subCount = [...state.agents.values()].filter(a => a.parentId && a.spawnTime >= d.timestamp && a.spawnTime < nextTime).length;
      const mainCount = state.toolCalls.filter(tc => tc.agentId === 'ag_main' && tc.startTime >= d.timestamp && tc.startTime < nextTime).length;
      tip += `<br>${subCount} sub-agents · ${mainCount} main tools`;
      if (d.tokens) tip += ` · ${d.tokens.toLocaleString()} tok`;
      tip += `<br><span class="dim" style="font-style:italic">Click for details</span>`;
      return tip;
    }
    return esc(d.name);
  }
  if (d.column === 1) {
    // Main Agent node
    const tools = d.mainToolCalls || [];
    const cats = {};
    tools.forEach(tc => { cats[tc.toolName] = (cats[tc.toolName] || 0) + 1; });
    let tip = `<span class="label">Main Agent</span>`;
    if (d.promptIndex !== undefined) tip += ` <span class="dim">Turn ${d.promptIndex + 1}</span>`;
    if (d.subAgentCount !== undefined) tip += `<br>${d.subAgentCount} sub-agents dispatched`;
    if (d.model) tip += `<br>Model: ${esc(d.model)}`;
    if (tools.length > 0) tip += `<br>${Object.entries(cats).map(([k, v]) => `${v} ${esc(k)}`).join(', ')}`;
    if (d.tokens) tip += ` · ${d.tokens.toLocaleString()} tok`;
    tip += `<br><span class="dim" style="font-style:italic">Click for details</span>`;
    return tip;
  }
  if (d.column === 2) {
    // Decomposition / phase node
    if (d.isDirectWork) {
      const tools = d.mainToolCalls || [];
      const cats = {};
      tools.forEach(tc => { cats[tc.toolName] = (cats[tc.toolName] || 0) + 1; });
      let tip = `<span class="label">Direct Work</span>`;
      if (d.promptIndex !== undefined) tip += ` <span class="dim">Turn ${d.promptIndex + 1}</span>`;
      if (tools.length > 0) tip += `<br>${Object.entries(cats).map(([k, v]) => `${v} ${esc(k)}`).join(', ')}`;
      if (d.tokens) tip += ` · ${d.tokens.toLocaleString()} tok`;
      tip += `<br><span class="dim" style="font-style:italic">Click for details</span>`;
      return tip;
    }
    const agentCount = (d.agents || []).length;
    let tip = `<span class="label">${esc(d.name)}</span>`;
    if (d.promptIndex !== undefined) tip += ` <span class="dim">Turn ${d.promptIndex + 1}</span>`;
    tip += ` <span class="dim">CTX ${(d.cycleIndex || 0) + 1}</span>`;
    tip += `<br>Agents: ${agentCount}`;
    if (d.tokens) tip += ` · Tokens: ${d.tokens.toLocaleString()}`;
    const agentPreviews = (d.agents || []).slice(0, 4);
    if (agentPreviews.length > 0) {
      tip += '<ul class="tip-list">';
      agentPreviews.forEach(a => {
        tip += `<li class="dim">${esc((a.task || a.id).slice(0, 50))}</li>`;
      });
      if (agentCount > 4) tip += `<li class="dim">+${agentCount - 4} more</li>`;
      tip += '</ul>';
    }
    tip += `<span class="dim" style="font-style:italic">Click for details</span>`;
    return tip;
  }
  if (d.column === 3) {
    const agent = state.agents.get(d.id);
    if (agent) return agentTooltipHtml(agent);
    let tip = `<span class="label">${esc(d.name)}</span>`;
    if (d.tokens) tip += `<br>Tokens: ${d.tokens.toLocaleString()}`;
    return tip;
  }
  if (d.column === 4) {
    // Outcome node
    let tip = `<span class="label">${esc(d.name)}</span>`;
    if (d.status) tip += `<br>Status: ${d.status}`;
    if (d.promptIndex !== undefined) tip += `<br><span class="dim">Turn ${d.promptIndex + 1}</span>`;
    else if (d.cycleIndex !== undefined) tip += `<br><span class="dim">CTX ${d.cycleIndex + 1}</span>`;
    return tip;
  }
  return `<span class="label">${esc(d.name)}</span>`;
}

// --- Sankey panel ---

function renderSankey() {
  const container = document.getElementById('sankey-panel');
  const svg = d3.select('#sankey-svg');
  const emptyEl = document.getElementById('sankey-empty');

  if (state.agents.size === 0) {
    emptyEl.style.display = 'flex';
    svg.selectAll('*').remove();
    return;
  }
  emptyEl.style.display = 'none';

  // Populate metric toggle
  const toggleEl = document.getElementById('sankey-metric-toggle');
  if (toggleEl && !toggleEl.hasChildNodes()) {
    ['tokens', 'tools', 'equal'].forEach(m => {
      const btn = document.createElement('span');
      btn.className = `metric-btn${state.sankeyMetric === m ? ' active' : ''}`;
      btn.textContent = m;
      btn.onclick = () => { state.sankeyMetric = m; toggleEl.querySelectorAll('.metric-btn').forEach(b => b.classList.toggle('active', b.textContent === m)); renderSankey(); };
      toggleEl.appendChild(btn);
    });
  }

  const headerH = container.querySelector('.panel-header').offsetHeight;
  const width = container.clientWidth;
  const height = container.clientHeight - headerH;
  const margin = { top: 28, right: 100, bottom: 28, left: 60 };

  svg.attr('width', width).attr('height', height);
  svg.selectAll('*').remove();

  const agents = [...state.agents.values()];
  const totalTokens = agents.reduce((s, a) => s + a.tokensIn + a.tokensOut, 0) || 1;
  const metric = state.sankeyMetric;
  const agentWeight = (a) => {
    if (metric === 'tools') return Math.max(state.toolCalls.filter(t => t.agentId === a.id).length, 1);
    if (metric === 'equal') return 1;
    return Math.max(a.tokensIn + a.tokensOut, 1);
  };

  const agentColors = {
    main: '#9ca3af', Explore: '#60a5fa', Plan: '#a78bfa',
    Bash: '#22c55e', 'general-purpose': '#eab308',
  };

  const nodeMap = new Map();
  const links = [];

  const mainAgent = agents.find(a => a.id === 'ag_main' || a.label === 'main');
  const mainTokens = mainAgent ? mainAgent.tokensIn + mainAgent.tokensOut : 0;
  const subAgents = agents.filter(a => a.parentId && state.agents.has(a.parentId));

  const phaseNames = {
    'Explore': 'Explore codebase',
    'Plan': 'Plan architecture',
    'general-purpose': 'Implement features',
    'Bash': 'Run commands',
    'feature-dev:code-explorer': 'Explore codebase',
    'feature-dev:code-architect': 'Plan architecture',
    'feature-dev:code-reviewer': 'Review code',
  };

  // Helper: find context cycle index for a timestamp
  const cycleForTimestamp = (ts) => {
    const idx = state.contextCycles.findIndex((c, ci) => {
      const end = c.endTime || (state.sessionEndTime || Date.now());
      return ts >= c.startTime && ts < end;
    });
    return idx >= 0 ? idx : 0;
  };

  // Helper: find prompt index for an agent (most recent prompt before spawn)
  const promptForAgent = (a) => {
    let pi = 0;
    for (let i = state.userPrompts.length - 1; i >= 0; i--) {
      if (a.spawnTime >= state.userPrompts[i].timestamp) { pi = i; break; }
    }
    return pi;
  };

  // Column 0: Source nodes (one per user prompt)
  const maxLabelLen = state.userPrompts.length > 6 ? 30 : 40;
  state.userPrompts.forEach((prompt, i) => {
    const sourceId = `prompt_${i}`;
    const label = prompt.text.slice(0, maxLabelLen) + (prompt.text.length > maxLabelLen ? '...' : '');
    const nextPromptTime = state.userPrompts[i + 1]?.timestamp || state.sessionEndTime || Date.now();
    const promptAgents = subAgents.filter(a =>
      a.spawnTime >= prompt.timestamp && a.spawnTime < nextPromptTime
    );
    const mainTools = state.toolCalls.filter(tc =>
      tc.agentId === 'ag_main' && tc.startTime >= prompt.timestamp && tc.startTime < nextPromptTime
    );
    const promptTokens = promptAgents.reduce((s, a) => s + a.tokensIn + a.tokensOut, 0)
      + mainTools.reduce((s, tc) => s + (tc.tokensIn || 0) + (tc.tokensOut || 0), 0);
    const cycleIdx = cycleForTimestamp(prompt.timestamp);
    nodeMap.set(sourceId, {
      id: sourceId, name: label, column: 0,
      cycleIndex: cycleIdx, promptIndex: i,
      promptText: prompt.text, tokens: promptTokens || 1,
      timestamp: prompt.timestamp, agentId: 'ag_main',
      isPromptSource: true,
    });
  });

  // Column 1: Main Agent nodes (one per prompt)
  const mainAgentMap = new Map();
  state.userPrompts.forEach((prompt, i) => {
    const nextPromptTime = state.userPrompts[i + 1]?.timestamp || state.sessionEndTime || Date.now();
    const mainTools = state.toolCalls.filter(tc =>
      tc.agentId === 'ag_main' && tc.startTime >= prompt.timestamp && tc.startTime < nextPromptTime
    );
    const promptSubAgents = subAgents.filter(a =>
      a.spawnTime >= prompt.timestamp && a.spawnTime < nextPromptTime
    );
    const toolTokens = mainTools.reduce((s, tc) => s + (tc.tokensIn || 0) + (tc.tokensOut || 0), 0);
    const cycleIdx = cycleForTimestamp(prompt.timestamp);
    mainAgentMap.set(`main_${i}`, {
      id: `main_${i}`, name: 'Main Agent', column: 1,
      cycleIndex: cycleIdx, promptIndex: i,
      tokens: toolTokens || 1,
      isMainAgentWork: true,
      mainToolCalls: mainTools,
      subAgentCount: promptSubAgents.length,
      model: mainAgent?.model || null,
    });
  });
  mainAgentMap.forEach(v => nodeMap.set(v.id, v));

  // Column 2: Decomposition phase nodes
  const phaseMap = new Map();

  // Sub-agent phase nodes — keyed by label + promptIndex
  subAgents.forEach(a => {
    const label = a.label || 'unknown';
    const groupIdx = promptForAgent(a);
    const cycleIdx = cycleForTimestamp(a.spawnTime);
    const key = `${label}_p${groupIdx}`;
    if (!phaseMap.has(key)) {
      phaseMap.set(key, {
        id: `phase_${label}_p${groupIdx}`,
        name: phaseNames[label] || label,
        column: 2, cycleIndex: cycleIdx,
        promptIndex: groupIdx,
        tokens: 0, agents: [],
        color: agentColors[label] || '#9ca3af',
      });
    }
    const phase = phaseMap.get(key);
    phase.tokens += agentWeight(a);
    phase.agents.push(a);
  });

  // Fallback: Direct Work or placeholder for prompts with no sub-agent phases
  state.userPrompts.forEach((prompt, i) => {
    const hasPhase = [...phaseMap.values()].some(p => p.promptIndex === i);
    if (!hasPhase) {
      const mainNode = mainAgentMap.get(`main_${i}`);
      const mainTools = mainNode?.mainToolCalls || [];
      if (mainTools.length > 0) {
        phaseMap.set(`direct_work_p${i}`, {
          id: `phase_direct_p${i}`, name: 'Direct Work',
          column: 2, cycleIndex: cycleForTimestamp(prompt.timestamp),
          promptIndex: i, tokens: mainNode.tokens || 1, agents: [],
          color: '#6b7280', isDirectWork: true, mainToolCalls: mainTools,
        });
      } else {
        phaseMap.set(`unknown_p${i}`, {
          id: `phase_unknown_p${i}`, name: 'Main Task',
          column: 2, cycleIndex: cycleForTimestamp(prompt.timestamp),
          promptIndex: i, tokens: 1, agents: [],
          color: '#9ca3af',
        });
      }
    }
  });

  phaseMap.forEach(v => nodeMap.set(v.id, v));

  // Source → Main Agent links
  mainAgentMap.forEach(mainNode => {
    const mainId = mainNode.id;
    let totalFlow = 0;
    phaseMap.forEach(phase => {
      if (phase.promptIndex === mainNode.promptIndex) totalFlow += Math.max(phase.tokens, 1);
    });
    totalFlow = Math.max(totalFlow, 1);
    const sourceId = `prompt_${mainNode.promptIndex}`;
    if (nodeMap.has(sourceId)) links.push({ source: sourceId, target: mainId, value: totalFlow });
  });

  // Main Agent → Decomposition phase links
  phaseMap.forEach(phase => {
    const mainId = phase.promptIndex !== undefined ? `main_${phase.promptIndex}` : null;
    if (mainId && nodeMap.has(mainId)) {
      links.push({ source: mainId, target: phase.id, value: Math.max(phase.tokens, 1) });
    }
  });

  // Column 3: Agent nodes — short IDs only
  const threshold = totalTokens * 0.05;
  let agentList = subAgents;
  let otherTokens = 0;

  if (subAgents.length > 20) {
    agentList = [];
    subAgents.forEach(a => {
      const tokens = a.tokensIn + a.tokensOut;
      if (tokens < threshold) otherTokens += tokens;
      else agentList.push(a);
    });
    if (otherTokens > 0) {
      const otherId = 'ag_other';
      nodeMap.set(otherId, { id: otherId, name: 'Other', column: 3, tokens: otherTokens, status: 'success', label: 'other' });
      phaseMap.forEach(phase => {
        links.push({ source: phase.id, target: otherId, value: Math.max(otherTokens / phaseMap.size, 1) });
      });
    }
  }

  const modelAbbr = (m) => {
    if (!m) return '';
    if (m.includes('opus')) return 'Op';
    if (m.includes('sonnet')) return 'So';
    if (m.includes('haiku')) return 'Ha';
    return m.slice(0, 2);
  };
  agentList.forEach(a => {
    const tokens = a.tokensIn + a.tokensOut;
    const abbr = modelAbbr(a.model);
    const name = abbr ? `${abbr} ${a.id.slice(-6)}` : a.id.slice(-6);
    nodeMap.set(a.id, { id: a.id, name, column: 3, tokens, status: a.status, label: a.label,
      promptIndex: promptForAgent(a),
    });
  });

  // Links: phase → agents (matched by label + group)
  agentList.forEach(a => {
    const w = agentWeight(a);
    const label = a.label || 'unknown';
    const pi = promptForAgent(a);
    const key = `${label}_p${pi}`;
    const phase = phaseMap.get(key);
    if (phase) {
      links.push({ source: phase.id, target: a.id, value: w });
    }
  });

  // Column 4: File operation outcomes — per prompt chain
  const outcomeMap = new Map();
  const agentOutcomes = new Map(); // agentId → { read, written, errors }
  const promptOutcomes = new Map(); // key → { read, written, errors, running }

  // Initialize per-prompt outcome buckets
  state.userPrompts.forEach((_, i) => promptOutcomes.set(i, { read: 0, written: 0, errors: 0, running: false }));

  // Count sub-agent file ops per chain
  agentList.forEach(a => {
    const ao = { read: 0, written: 0, errors: 0 };
    const pi = promptForAgent(a);
    const po = promptOutcomes.get(pi) || promptOutcomes.values().next().value;
    const tools = state.toolCalls.filter(t => t.agentId === a.id);
    tools.forEach(tc => {
      if (tc.hasError) { ao.errors++; po.errors++; }
      else if (['Read', 'Glob', 'Grep', 'WebFetch', 'WebSearch'].includes(tc.toolName)) { ao.read++; po.read++; }
      else if (['Write', 'Edit', 'NotebookEdit'].includes(tc.toolName)) { ao.written++; po.written++; }
    });
    if (a.status === 'running') po.running = true;
    agentOutcomes.set(a.id, ao);
  });

  // Count main agent file ops (for Direct Work decomposition nodes → outcomes)
  const mainWorkOutcomes = new Map();
  phaseMap.forEach((phase, key) => {
    if (!phase.isDirectWork) return;
    const ao = { read: 0, written: 0, errors: 0 };
    const pi = phase.promptIndex;
    const po = promptOutcomes.get(pi) || promptOutcomes.values().next().value;
    (phase.mainToolCalls || []).forEach(tc => {
      if (tc.hasError) { ao.errors++; po.errors++; }
      else if (['Read', 'Glob', 'Grep', 'WebFetch', 'WebSearch'].includes(tc.toolName)) { ao.read++; po.read++; }
      else if (['Write', 'Edit', 'NotebookEdit'].includes(tc.toolName)) { ao.written++; po.written++; }
    });
    mainWorkOutcomes.set(phase.id, ao);
  });

  // Create per-prompt outcome nodes
  promptOutcomes.forEach((po, idx) => {
    const ci = cycleForTimestamp(state.userPrompts[idx]?.timestamp || 0);
    const suffix = `p${idx}`;
    let created = false;
    if (po.read > 0) {
      const id = `out_read_${suffix}`;
      outcomeMap.set(id, { id, name: `${po.read} read`, column: 4, status: 'success', outcomeType: 'read',
        promptIndex: idx, cycleIndex: ci });
      created = true;
    }
    if (po.written > 0) {
      const id = `out_written_${suffix}`;
      outcomeMap.set(id, { id, name: `${po.written} written`, column: 4, status: 'success', outcomeType: 'written',
        promptIndex: idx, cycleIndex: ci });
      created = true;
    }
    if (po.errors > 0) {
      const id = `out_errors_${suffix}`;
      outcomeMap.set(id, { id, name: `${po.errors} errors`, column: 4, status: 'error', outcomeType: 'errors',
        promptIndex: idx, cycleIndex: ci });
      created = true;
    }
    if (po.running) {
      const id = `out_running_${suffix}`;
      outcomeMap.set(id, { id, name: 'In Progress', column: 4, status: 'running', outcomeType: 'running',
        promptIndex: idx, cycleIndex: ci });
      created = true;
    }
    if (!created) {
      const hasContent = [...phaseMap.values()].some(p => p.promptIndex === idx);
      if (hasContent) {
        const id = `out_done_${suffix}`;
        outcomeMap.set(id, { id, name: 'Completed', column: 4, status: 'success', outcomeType: 'done',
          promptIndex: idx, cycleIndex: ci });
      }
    }
  });

  outcomeMap.forEach((v, k) => nodeMap.set(k, v));

  // Links: agents → per-chain outcomes (weighted by current metric)
  agentList.forEach(a => {
    const ao = agentOutcomes.get(a.id);
    const w = agentWeight(a);
    const pi = promptForAgent(a);
    const suffix = `p${pi}`;
    if (a.status === 'running' && outcomeMap.has(`out_running_${suffix}`)) {
      links.push({ source: a.id, target: `out_running_${suffix}`, value: w, agentStatus: 'running' });
      return;
    }
    const totalOps = ao.read + ao.written + ao.errors;
    if (totalOps > 0) {
      if (ao.read > 0 && outcomeMap.has(`out_read_${suffix}`))
        links.push({ source: a.id, target: `out_read_${suffix}`, value: w * (ao.read / totalOps), agentStatus: a.status });
      if (ao.written > 0 && outcomeMap.has(`out_written_${suffix}`))
        links.push({ source: a.id, target: `out_written_${suffix}`, value: w * (ao.written / totalOps), agentStatus: a.status });
      if (ao.errors > 0 && outcomeMap.has(`out_errors_${suffix}`))
        links.push({ source: a.id, target: `out_errors_${suffix}`, value: w * (ao.errors / totalOps), agentStatus: a.status });
    } else {
      const fallbackKey = [`out_done_${suffix}`, `out_running_${suffix}`].find(k => outcomeMap.has(k))
        || [...outcomeMap.keys()].find(k => k.endsWith(`_${suffix}`));
      if (fallbackKey) links.push({ source: a.id, target: fallbackKey, value: w, agentStatus: a.status });
    }
  });

  // Links: Direct Work decomposition nodes → per-chain outcomes
  mainWorkOutcomes.forEach((ao, phaseId) => {
    const phase = nodeMap.get(phaseId);
    if (!phase) return;
    const w = phase.tokens || 1;
    const pi = phase.promptIndex;
    const suffix = `p${pi}`;
    const totalOps = ao.read + ao.written + ao.errors;
    if (totalOps > 0) {
      if (ao.read > 0 && outcomeMap.has(`out_read_${suffix}`))
        links.push({ source: phaseId, target: `out_read_${suffix}`, value: w * (ao.read / totalOps) });
      if (ao.written > 0 && outcomeMap.has(`out_written_${suffix}`))
        links.push({ source: phaseId, target: `out_written_${suffix}`, value: w * (ao.written / totalOps) });
      if (ao.errors > 0 && outcomeMap.has(`out_errors_${suffix}`))
        links.push({ source: phaseId, target: `out_errors_${suffix}`, value: w * (ao.errors / totalOps) });
    } else {
      const fallbackKey = [`out_done_${suffix}`, `out_running_${suffix}`].find(k => outcomeMap.has(k))
        || [...outcomeMap.keys()].find(k => k.endsWith(`_${suffix}`));
      if (fallbackKey) links.push({ source: phaseId, target: fallbackKey, value: w });
    }
  });

  const nodes = [...nodeMap.values()];
  const nodeIndex = new Map(nodes.map((n, i) => [n.id, i]));

  const sankeyLinks = links
    .filter(l => nodeIndex.has(l.source) && nodeIndex.has(l.target) && l.source !== l.target)
    .map(l => ({ source: nodeIndex.get(l.source), target: nodeIndex.get(l.target), value: 1, metricValue: l.value, agentStatus: l.agentStatus }));

  if (nodes.length < 2 || sankeyLinks.length === 0) return;

  try {
    const dynamicPadding = nodes.length > 15 ? 6 : nodes.length > 8 ? 10 : 16;
    const sankeyGen = d3.sankey()
      .nodeId(d => d.index)
      .nodeAlign(d3.sankeyLeft)
      .nodeWidth(12)
      .nodePadding(dynamicPadding)
      .extent([[margin.left, margin.top], [width - margin.right, height - margin.bottom]]);

    // Assign cycleIndex + promptIndex — source (col 0), main agent (col 1), phase (col 2) already have it
    // Only need to assign for agent (col 3) and outcome (col 4) nodes
    nodes.forEach(n => {
      if (n.cycleIndex === undefined) {
        if (n.column === 3) {
          const agent = state.agents.get(n.id);
          if (agent && state.contextCycles.length > 1) {
            n.cycleIndex = state.contextCycles.findIndex((_, i) => isAgentInContextCycle(agent, i));
            if (n.cycleIndex < 0) n.cycleIndex = 0;
          } else {
            n.cycleIndex = 0;
          }
        } else {
          n.cycleIndex = 0; // outcomes
        }
      }
    });

    sankeyGen.nodeSort((a, b) => {
      if (a.cycleIndex !== b.cycleIndex) return a.cycleIndex - b.cycleIndex;
      if (a.promptIndex !== undefined && b.promptIndex !== undefined) {
        return a.promptIndex - b.promptIndex;
      }
      return 0;
    });

    const { nodes: sNodes, links: sLinks } = sankeyGen({
      nodes: nodes.map((n, i) => ({ ...n, index: i })),
      links: sankeyLinks,
    });

    const colWidths = { 0: 140, 1: 100, 2: 130, 3: 60, 4: 90 };

    const nodeColor = (d) => {
      if (d.column === 0) return 'var(--accent)';
      if (d.column === 1) return '#6b7280'; // Main Agent — always gray
      if (d.column === 2) return d.color || 'var(--text-dim)'; // Decomposition phases
      if (d.column === 4) {
        if (d.status === 'error') return 'var(--red)';
        if (d.status === 'running') return 'var(--accent)';
        if (d.outcomeType === 'read') return '#60a5fa';
        if (d.outcomeType === 'written') return 'var(--green)';
        return 'var(--green)';
      }
      // Column 3: agents
      if (d.label) {
        const colors = { main: '#9ca3af', Explore: '#60a5fa', Plan: '#a78bfa', Bash: '#22c55e', 'general-purpose': '#eab308' };
        return colors[d.label] || '#9ca3af';
      }
      return 'var(--text-dim)';
    };

    // Gradient defs for links — source color → target color
    const defs = svg.append('defs');

    // Diagonal stripe pattern for main agent work nodes
    const stripe = defs.append('pattern')
      .attr('id', 'main-agent-stripe').attr('patternUnits', 'userSpaceOnUse')
      .attr('width', 4).attr('height', 4).attr('patternTransform', 'rotate(45)');
    stripe.append('rect').attr('width', 4).attr('height', 4).attr('fill', '#6b7280');
    stripe.append('line').attr('x1', 0).attr('y1', 0).attr('x2', 0).attr('y2', 4)
      .attr('stroke', 'rgba(255,255,255,0.08)').attr('stroke-width', 1);
    sLinks.forEach((link, i) => {
      const grad = defs.append('linearGradient')
        .attr('id', `sg-${i}`).attr('x1', 0).attr('y1', 0).attr('x2', 1).attr('y2', 0);
      grad.append('stop').attr('offset', '0%').attr('stop-color', nodeColor(link.source));
      grad.append('stop').attr('offset', '20%').attr('stop-color', nodeColor(link.source));
      grad.append('stop').attr('offset', '80%').attr('stop-color', nodeColor(link.target));
      grad.append('stop').attr('offset', '100%').attr('stop-color', nodeColor(link.target));
    });

    const g = svg.append('g');

    // Column headers
    const headers = ['PROMPTS', 'MAIN AGENT', 'DECOMPOSITION', 'AGENTS', 'OUTCOMES'];
    headers.forEach((label, col) => {
      const colNodes = sNodes.filter(n => n.column === col);
      if (!colNodes.length) return;
      const cx = d3.mean(colNodes, n => (n.x0 + n.x1) / 2);
      g.append('text').attr('class', 'sankey-col-header')
        .attr('x', cx).attr('y', margin.top - 6).text(label);
    });

    // Context cycle swim-lanes (alternating background bands spanning all columns)
    if (state.contextCycles.length > 1) {
      const laneColors = ['rgba(255,255,255,0.03)', 'rgba(255,255,255,0.07)'];
      state.contextCycles.forEach((cycle, i) => {
        // Include source, phase, and agent nodes in this cycle's lane
        const cycleNodes = sNodes.filter(n => n.cycleIndex === i);
        if (cycleNodes.length === 0) return;
        const yMin = d3.min(cycleNodes, n => n.y0);
        const yMax = d3.max(cycleNodes, n => n.y1);
        const pad = 10;
        g.insert('rect', ':first-child')
          .attr('x', 0)
          .attr('width', width)
          .attr('y', yMin - pad).attr('height', yMax - yMin + pad * 2)
          .attr('rx', 6).attr('fill', laneColors[i % laneColors.length])
          .attr('cursor', 'pointer')
          .on('click', () => highlightContextCycle(i))
          .on('mouseenter', (e) => showTooltip(e, `<span class="label">CTX ${i + 1}</span><br><span class="dim">${esc(cycle.trigger)} · Click to highlight</span>`))
          .on('mouseleave', hideTooltip);
        // Lane label
        g.insert('text', ':first-child')
          .attr('x', 6).attr('y', yMin - pad + 12)
          .attr('font-size', '9px').attr('fill', 'rgba(255,255,255,0.25)')
          .attr('font-family', "'DM Mono', monospace")
          .text(`CTX ${i + 1}`);
      });
    }

    // Node pill dimensions (defined before linkPath so links can anchor to pill bounds)
    const nodeH = (d) => Math.min(Math.max(d.y1 - d.y0, 22), 50);
    const nodeYOff = (d) => {
      const allocated = d.y1 - d.y0;
      const actual = nodeH(d);
      return actual < allocated ? (allocated - actual) / 2 : 0;
    };

    // Stroked curve links (matching V4b mockup — thin paths, low opacity, nodes on top)
    const nw = 12; // sankey nodeWidth
    const linkPath = (d) => {
      const sx = d.source.x0 + (colWidths[d.source.column] + nw) / 2;
      const tx = d.target.x0 - (colWidths[d.target.column] - nw) / 2;

      // Target vertical center of each pill edge
      const sy = d.source.y0 + nodeYOff(d.source) + nodeH(d.source) / 2;
      const ty = d.target.y0 + nodeYOff(d.target) + nodeH(d.target) / 2;

      const mx = (sx + tx) / 2;
      return `M${sx},${sy} C${mx},${sy} ${mx},${ty} ${tx},${ty}`;
    };

    g.selectAll('.sankey-link')
      .data(sLinks)
      .join('path')
      .attr('class', d => {
        let cls = 'sankey-link';
        const src = d.source;
        const tgt = d.target;
        if ((tgt && tgt.status === 'running') || (src && src.status === 'running')) cls += ' in-progress';
        if (state.selectedAgentId) {
          if (src.id !== state.selectedAgentId && tgt.id !== state.selectedAgentId) cls += ' dimmed';
        }
        if (state.highlightedContextCycle !== null) {
          const hc = state.highlightedContextCycle;
          const srcInCycle = src.cycleIndex === hc;
          const tgtInCycle = tgt.cycleIndex === hc;
          if (!srcInCycle && !tgtInCycle) cls += ' dimmed';
        }
        if (state.highlightedPromptIndex !== null) {
          const hp = state.highlightedPromptIndex;
          const srcMatch = src.promptIndex === hp;
          const tgtMatch = tgt.promptIndex === hp;
          if (!srcMatch && !tgtMatch) cls += ' prompt-dimmed';
        }
        return cls;
      })
      .attr('d', linkPath)
      .attr('stroke', (d, i) => `url(#sg-${i})`)
      .attr('stroke-width', (() => {
        const maxMetric = d3.max(sLinks, l => l.metricValue) || 1;
        return d => Math.max((d.metricValue / maxMetric) * 20, 1.5);
      })())
      .on('mouseenter', (e, d) => {
        const metricLabel = { tokens: 'Tokens', tools: 'Tool calls', equal: 'Weight' }[metric] || 'Value';
        let tip = `${esc(d.source.name)} → ${esc(d.target.name)}<br>${metricLabel}: ${Math.round(d.metricValue).toLocaleString()}`;
        // Phase→agent links: show agent task preview
        if (d.source.column === 2 && d.target.column === 3) {
          const agent = state.agents.get(d.target.id);
          if (agent && agent.task) tip += `<br><span class="dim">${esc(agent.task.slice(0, 80))}</span>`;
        }
        showTooltip(e, tip);
      })
      .on('mouseleave', hideTooltip);

    // Node groups — translate to wide rect center
    const node = g.selectAll('.sankey-node')
      .data(sNodes)
      .join('g')
      .attr('class', 'sankey-node')
      .attr('transform', d => `translate(${d.x0},${d.y0 + nodeYOff(d)})`);

    // Wide colored rects per column
    node.append('rect')
      .attr('x', d => -(colWidths[d.column] - (d.x1 - d.x0)) / 2)
      .attr('width', d => colWidths[d.column] || 12)
      .attr('height', nodeH)
      .attr('rx', 4)
      .attr('fill', d => d.isMainAgentWork ? 'url(#main-agent-stripe)' : nodeColor(d))
      .attr('class', d => d.isMainAgentWork ? 'main-agent-node' : '')
      .attr('opacity', d => {
        if (state.selectedAgentId && d.id !== state.selectedAgentId && d.column === 3) return 0.3;
        if (state.highlightedContextCycle !== null) {
          if (d.cycleIndex !== undefined && d.cycleIndex !== state.highlightedContextCycle) return 0.3;
          if (d.column === 3) {
            const agent = state.agents.get(d.id);
            if (agent && !isAgentInContextCycle(agent, state.highlightedContextCycle)) return 0.3;
          }
        }
        if (state.highlightedPromptIndex !== null) {
          if (d.promptIndex !== undefined && d.promptIndex !== state.highlightedPromptIndex) return 0.3;
          if (d.column === 3 && d.promptIndex === undefined) return 0.3;
        }
        return 0.85;
      })
      .on('click', (e, d) => {
        if (d.column === 0) {
          if (d.isPromptSource) openPromptDrawer(d);
          else openSourceDrawer(d);
        }
        else if (d.column === 1) openMainWorkDrawer(d);
        else if (d.column === 2) {
          if (d.isDirectWork) openMainWorkDrawer(d);
          else openPhaseDrawer(d);
        }
        else if (d.column === 3) selectAgent(d.id);
      })
      .on('mouseenter', (e, d) => showTooltip(e, nodeTooltipHtml(d)))
      .on('mouseleave', hideTooltip);

    // Labels centered inside rects
    node.append('text')
      .attr('x', d => (d.x1 - d.x0) / 2)
      .attr('y', d => nodeH(d) / 2)
      .attr('dy', '0.35em')
      .attr('text-anchor', 'middle')
      .text(d => {
        const maxLen = { 0: 20, 1: 14, 2: 18, 3: 9, 4: 14 }[d.column] || 16;
        return d.name.length > maxLen ? d.name.slice(0, maxLen - 1) + '\u2026' : d.name;
      });

  } catch (e) {
    console.warn('Sankey render error:', e);
  }
}

function findTaskForAgent(agent) {
  for (const [id, task] of state.tasks) {
    if (task.owner && agent.id.includes(task.owner)) return task;
    if (agent.task && task.subject && fuzzyMatch(agent.task, task.subject)) return task;
  }
  return null;
}

// --- Stats panel ---

function renderStats() {
  const agents = [...state.agents.values()];
  const now = Date.now();

  const totalTokens = agents.reduce((s, a) => s + a.tokensIn + a.tokensOut, 0);
  const avgTokens = agents.length > 0 ? Math.round(totalTokens / agents.length) : 0;
  document.getElementById('val-tokens').textContent = totalTokens.toLocaleString();
  document.getElementById('sec-tokens').textContent = `avg ${avgTokens.toLocaleString()}/agent`;
  drawSparkline('spark-tokens', state.tokenHistory);

  const totalCost = agents.reduce((s, a) => s + (a.tokensIn * 15 / 1_000_000) + (a.tokensOut * 75 / 1_000_000), 0);
  const avgCost = agents.length > 0 ? totalCost / agents.length : 0;
  document.getElementById('val-cost').textContent = `$${totalCost.toFixed(2)}`;
  document.getElementById('sec-cost').textContent = `avg $${avgCost.toFixed(2)}/agent`;
  drawSparkline('spark-cost', state.costHistory);

  const active = agents.filter(a => a.status === 'running').length;
  const completed = agents.filter(a => a.status === 'success').length;
  const failed = agents.filter(a => a.status === 'error').length;
  document.getElementById('val-agents').textContent = agents.length;
  document.getElementById('sec-agents').textContent = `${active} active · ${completed} done · ${failed} err`;
  drawSparkline('spark-agents', state.agentCountHistory);

  if (state.sessionStart) {
    const elapsed = (now - state.sessionStart) / 1000;
    document.getElementById('val-duration').textContent = formatDuration(elapsed);
    const done = completed + failed;
    if (done > 0 && active > 0) {
      const avgDur = agents.filter(a => a.status !== 'running').reduce((s, a) => s + (a.durationMs || 0), 0) / done;
      document.getElementById('sec-duration').textContent = `est. remaining: ${formatDuration((active / done) * (avgDur / 1000))}`;
    } else {
      document.getElementById('sec-duration').textContent = `est. remaining: —`;
    }
  }

  const totalCompleted = agents.filter(a => a.status !== 'running').length;
  if (totalCompleted > 0) {
    const successRate = (completed / totalCompleted * 100).toFixed(0);
    document.getElementById('val-efficiency').textContent = `${successRate}%`;
    document.getElementById('efficiency-bar').style.width = `${successRate}%`;
  } else {
    document.getElementById('val-efficiency').textContent = '—';
    document.getElementById('efficiency-bar').style.width = '0%';
  }
}

// --- Sidebar ---

function renderSidebar() {
  renderAgentTable();
  renderTasks();
  renderPlanPanel();
}

function renderAgentTable() {
  const agents = [...state.agents.values()];
  const container = document.getElementById('agent-cards-container');
  const sorted = [...agents].sort((a, b) => {
    let va, vb;
    switch (state.sortCol) {
      case 'agent': va = a.label + a.id; vb = b.label + b.id; break;
      case 'tokens': va = a.tokensIn + a.tokensOut; vb = b.tokensIn + b.tokensOut; break;
      case 'duration': va = a.durationMs || 0; vb = b.durationMs || 0; break;
      case 'status': va = a.status; vb = b.status; break;
      default: va = a.id; vb = b.id;
    }
    if (typeof va === 'string') return state.sortAsc ? va.localeCompare(vb) : vb.localeCompare(va);
    return state.sortAsc ? va - vb : vb - va;
  });

  container.innerHTML = sorted.map(a => {
    const tokens = a.tokensIn + a.tokensOut;
    const dur = a.durationMs ? formatDuration(a.durationMs / 1000) : '—';
    const statusClass = a.status === 'running' ? 'running' : a.status === 'error' ? 'error' : 'success';
    const selected = state.selectedAgentId === a.id ? 'selected' : '';
    const statusLabel = a.status === 'running' ? 'Active' : a.status === 'error' ? 'Error' : 'Done';
    const modelTag = a.model ? ` <span style="font-family:'DM Mono',monospace;font-size:9px;color:var(--text-dim);opacity:0.7;margin-left:4px;padding:1px 5px;background:rgba(255,255,255,0.04);border-radius:3px">${esc(a.model)}</span>` : '';
    return `<div class="agent-card ${selected}" data-agent-id="${esc(a.id)}">
      <div class="agent-card-top">
        <span class="agent-card-name">${esc(a.label)} ${esc(a.id.slice(-6))}${modelTag}</span>
        <span class="agent-status-pill ${statusClass}"><span class="pill-dot"></span>${statusLabel}</span>
      </div>
      <div class="agent-card-meta">
        <span>${tokens.toLocaleString()} tok</span>
        <span>${dur}</span>
      </div>
      ${a.task ? `<div class="agent-card-task" title="${esc(a.task)}">${esc(a.task.slice(0, 60))}</div>` : ''}
    </div>`;
  }).join('');
}

function renderTasks() {
  const list = document.getElementById('task-list');
  if (state.tasks.size === 0) {
    list.innerHTML = '<li style="padding:24px;text-align:center;color:var(--text-dim);font-size:12px">No tasks detected</li>';
    return;
  }

  list.innerHTML = [...state.tasks.values()].map(t => {
    const statusIcon = t.status === 'completed' ? '<span style="font-size:8px">&#10003;</span>'
      : t.status === 'error' ? '<span style="font-size:8px">&#10007;</span>'
      : t.status === 'in_progress' ? '<span style="font-size:8px">&#9654;</span>'
      : '';
    return `<li class="task-item" data-task-id="${t.id}">
      <div class="task-status-icon ${t.status}">${statusIcon}</div>
      <div class="task-info">
        <div class="task-subject">${esc(t.subject)}</div>
        ${t.description ? `<div class="task-desc">${esc(t.description)}</div>` : ''}
        ${t.owner ? `<div class="task-owner">${esc(t.owner)}</div>` : ''}
      </div>
    </li>`;
  }).join('');
}

function renderPlanPanel() {
  const panel = document.getElementById('plan-panel');
  if (state.planCycles.length === 0) {
    panel.innerHTML = '<div class="plan-empty">No plan detected</div>';
    return;
  }

  let html = '';
  state.planCycles.forEach((cycle, i) => {
    const statusBadge = cycle.active
      ? '<span class="plan-status-badge active">ACTIVE</span>'
      : '<span class="plan-status-badge inactive">COMPLETED</span>';
    const base = state.sessionStart || cycle.startTime;
    const timeRange = `${formatTime(cycle.startTime, base)}${cycle.endTime ? ' — ' + formatTime(cycle.endTime, base) : ' — ongoing'}`;

    // Find which context cycle this plan falls within
    const ctxIdx = state.contextCycles.findIndex(ctx => {
      const end = ctx.endTime || (state.sessionEndTime || Date.now());
      return cycle.startTime >= ctx.startTime && cycle.startTime < end;
    });
    const ctxLabel = ctxIdx >= 0 ? `CTX ${ctxIdx + 1}` : '';

    html += `<div class="plan-cycle-card" data-cycle-idx="${i}">`;
    html += `<div class="plan-cycle-header"><span class="plan-cycle-num">Plan ${i + 1}</span>${statusBadge}`;
    if (ctxLabel) html += `<span style="font-size:9px;color:var(--text-dim);margin-left:auto;font-family:'DM Mono',monospace">${ctxLabel}</span>`;
    html += `</div>`;
    html += `<div style="font-size:10px;color:var(--text-dim);margin-bottom:6px">${timeRange}</div>`;
    if (cycle.content) {
      html += `<div style="font-size:10px;color:var(--text-dim);margin-bottom:4px">${esc(cycle.content.filePath)}</div>`;
      html += `<div class="plan-content" style="max-height:200px">${esc(cycle.content.preview)}</div>`;
    } else if (cycle.active) {
      html += '<div style="font-size:10px;color:var(--text-dim)">Waiting for plan content...</div>';
    }
    html += '</div>';
  });

  panel.innerHTML = html;
}

// --- Info bar ---

function renderInfoBar() {
  document.getElementById('info-events').textContent = `${state.events.length} events`;

  const planBadge = document.getElementById('info-plan-mode');
  if (state.planMode) planBadge.classList.add('visible');
  else planBadge.classList.remove('visible');

  const compBadge = document.getElementById('info-compactions');
  if (state.compactions.length > 0) {
    compBadge.textContent = `${state.compactions.length} compaction${state.compactions.length > 1 ? 's' : ''}`;
    compBadge.classList.add('visible');
  } else {
    compBadge.classList.remove('visible');
  }

  const ctxBadge = document.getElementById('info-context-cycles');
  if (state.contextCycles.length > 1) {
    let ctxText = `${state.contextCycles.length} contexts`;
    if (state.userPrompts.length > 0) ctxText += ` · ${state.userPrompts.length} prompts`;
    ctxBadge.textContent = ctxText;
    ctxBadge.style.display = 'inline-flex';
  } else if (state.userPrompts.length > 0) {
    ctxBadge.textContent = `${state.userPrompts.length} prompts`;
    ctxBadge.style.display = 'inline-flex';
  } else {
    ctxBadge.style.display = 'none';
  }

  const tasksBadge = document.getElementById('info-tasks');
  if (state.tasks.size > 0) {
    const pending = [...state.tasks.values()].filter(t => t.status === 'pending').length;
    const inProg = [...state.tasks.values()].filter(t => t.status === 'in_progress').length;
    const parts = [`${state.tasks.size} tasks`];
    if (pending > 0) parts.push(`${pending} pending`);
    if (inProg > 0) parts.push(`${inProg} active`);
    tasksBadge.textContent = parts.join(' · ');
  } else {
    tasksBadge.textContent = '0 tasks';
  }

  const errorBadge = document.getElementById('info-errors');
  const errorCount = [...state.agents.values()].filter(a => a.status === 'error').length +
    state.toolCalls.filter(tc => tc.hasError).length;
  if (errorCount > 0) {
    errorBadge.textContent = `${errorCount} errors`;
    errorBadge.classList.add('visible');
  } else {
    errorBadge.classList.remove('visible');
  }
}

function drawSparkline(id, data) {
  if (data.length < 2) return;
  const svg = d3.select(`#${id}`);
  svg.selectAll('*').remove();
  const w = 64;
  const h = 28;
  svg.attr('width', w).attr('height', h);
  const xS = d3.scaleLinear().domain([0, data.length - 1]).range([0, w]);
  const yS = d3.scaleLinear().domain([0, d3.max(data) || 1]).range([h - 2, 2]);
  const line = d3.line().x((d, i) => xS(i)).y(d => yS(d)).curve(d3.curveMonotoneX);
  svg.append('path').datum(data).attr('d', line);
}

function formatDuration(seconds) {
  if (seconds < 60) return `${seconds.toFixed(0)}s`;
  if (seconds < 3600) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m}:${String(s).padStart(2, '0')}`;
  }
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  return `${h}:${String(m).padStart(2, '0')}:00`;
}

// --- Cross-panel interactions ---

function selectAgent(agentId) {
  if (state.selectedAgentId === agentId) {
    state.selectedAgentId = null;
    closeDrawer();
  } else {
    state.selectedAgentId = agentId;
    openAgentDrawer(agentId);
  }
  document.dispatchEvent(new CustomEvent('agent-select', { detail: { agentId: state.selectedAgentId } }));
  render();
}

// --- Detail drawer ---

function openAgentDrawer(agentId) {
  const agent = state.agents.get(agentId);
  if (!agent) return;

  const drawer = document.getElementById('detail-drawer');
  const body = document.getElementById('drawer-body');
  document.getElementById('drawer-title').textContent = `${agent.label} ${agentId.slice(-8)}`;
  drawer.classList.add('open');

  const tokens = agent.tokensIn + agent.tokensOut;
  const cost = ((agent.tokensIn * 15 / 1_000_000) + (agent.tokensOut * 75 / 1_000_000)).toFixed(3);
  const dur = agent.endTime ? ((agent.endTime - agent.spawnTime) / 1000).toFixed(1) + 's' : 'running';
  const agentTools = state.toolCalls.filter(t => t.agentId === agentId);
  const errorTools = agentTools.filter(t => t.hasError);

  let html = `<div class="drawer-section"><h3>Overview</h3><div class="drawer-kv">`;
  html += `<span class="k">Status</span><span class="v"><span class="badge ${agent.status === 'running' ? 'running' : agent.status === 'error' ? 'error' : 'success'}">${agent.status}</span></span>`;
  if (agent.model) html += `<span class="k">Model</span><span class="v">${esc(agent.model)}</span>`;
  html += `<span class="k">Task</span><span class="v">${esc(agent.task || '—')}</span>`;
  html += `<span class="k">Duration</span><span class="v">${dur}</span>`;
  html += `<span class="k">Tokens</span><span class="v">${tokens.toLocaleString()} (in: ${agent.tokensIn.toLocaleString()}, out: ${agent.tokensOut.toLocaleString()})</span>`;
  html += `<span class="k">Cost</span><span class="v">$${cost}</span>`;
  html += `<span class="k">Tools</span><span class="v">${agentTools.length} calls${errorTools.length ? `, ${errorTools.length} errors` : ''}</span>`;
  html += `</div></div>`;

  if (agentTools.length > 0) {
    html += `<div class="drawer-section"><h3>Tool Calls</h3><ul class="drawer-tool-list">`;
    for (const tc of agentTools) {
      html += `<li><span class="drawer-tool-name">${esc(tc.toolName)}</span>`;
      if (tc.hasError) html += ` <span class="drawer-tool-error">ERROR</span>`;
      if (tc.params) html += ` <span class="dim">${esc(tc.params)}</span>`;
      if (tc.responseSummary) html += `<div class="drawer-tool-output">${esc(tc.responseSummary)}</div>`;
      html += `</li>`;
    }
    html += `</ul></div>`;
  }

  html += `<div id="drawer-transcript"><div class="drawer-loading">Loading transcript...</div></div>`;
  body.innerHTML = html;
  loadTranscriptDetail(agentId, agent);
}

async function loadTranscriptDetail(agentId, agent) {
  const container = document.getElementById('drawer-transcript');
  if (!container) return;

  let transcriptPath = agent.transcriptPath;

  if (!transcriptPath && agent.parentId) {
    const parent = state.agents.get(agent.parentId);
    if (parent && parent.transcriptPath) {
      try {
        const res = await fetch(`/api/subagents?transcript=${encodeURIComponent(parent.transcriptPath)}`);
        const subagents = await res.json();
        const match = subagents.find(s => s.prompt && agent.task && fuzzyMatch(s.prompt, agent.task));
        if (match) transcriptPath = match.path;
      } catch {}
    }
  }

  if (!transcriptPath) {
    container.innerHTML = `<div class="drawer-section"><p class="dim" style="padding:8px 0;font-size:11px">No transcript available</p></div>`;
    return;
  }

  try {
    const res = await fetch(`/api/transcript?path=${encodeURIComponent(transcriptPath)}`);
    if (!res.ok) throw new Error(res.statusText);
    const data = await res.json();
    container.innerHTML = renderTranscriptDetail(data);
  } catch (err) {
    container.innerHTML = `<div class="drawer-section"><p class="dim" style="padding:8px 0;font-size:11px">Failed to load transcript: ${esc(err.message)}</p></div>`;
  }
}

function fuzzyMatch(a, b) {
  const al = a.toLowerCase().slice(0, 100);
  const bl = b.toLowerCase().slice(0, 100);
  if (al.includes(bl) || bl.includes(al)) return true;
  const aWords = al.split(/\s+/).filter(w => w.length > 3);
  const bWords = bl.split(/\s+/).filter(w => w.length > 3);
  const overlap = aWords.filter(w => bWords.includes(w));
  return overlap.length >= Math.min(2, Math.min(aWords.length, bWords.length));
}

function renderTranscriptDetail(data) {
  let html = '';

  if (data.prompt) {
    html += `<div class="drawer-section"><h3>Prompt</h3><div class="drawer-prompt">${esc(data.prompt)}</div></div>`;
  }

  if (data.usage) {
    const u = data.usage;
    const total = u.input_tokens + u.output_tokens;
    html += `<div class="drawer-section"><h3>Token Breakdown</h3><div class="drawer-kv">`;
    html += `<span class="k">Input</span><span class="v">${u.input_tokens.toLocaleString()}</span>`;
    html += `<span class="k">Output</span><span class="v">${u.output_tokens.toLocaleString()}</span>`;
    html += `<span class="k">Cache Write</span><span class="v">${u.cache_creation_input_tokens.toLocaleString()}</span>`;
    html += `<span class="k">Cache Read</span><span class="v">${u.cache_read_input_tokens.toLocaleString()}</span>`;
    html += `<span class="k">Cache Hit</span><span class="v">${u.cache_hit_rate}</span>`;
    html += `</div>`;
    if (total > 0) {
      const ip = (u.input_tokens / total * 100).toFixed(0);
      const op = (u.output_tokens / total * 100).toFixed(0);
      html += `<div class="token-bar"><div class="input" style="width:${ip}%"></div><div class="output" style="width:${op}%"></div></div>`;
      html += `<div style="font-size:10px;color:var(--text-dim)"><span style="color:var(--accent)">input</span> ${ip}% · <span style="color:var(--purple)">output</span> ${op}%</div>`;
    }
    html += `</div>`;
  }

  if (data.messages && data.messages.length > 0) {
    const toolUses = data.messages.filter(m => m.type === 'tool_use');
    const toolResults = data.messages.filter(m => m.type === 'tool_result');
    if (toolUses.length > 0) {
      html += `<div class="drawer-section"><h3>Transcript Tool Calls (${toolUses.length})</h3><ul class="drawer-tool-list">`;
      for (const tu of toolUses.slice(0, 50)) {
        const result = toolResults.find(r => r.tool_use_id === tu.id);
        html += `<li><span class="drawer-tool-name">${esc(tu.name)}</span>`;
        if (result && result.is_error) html += ` <span class="drawer-tool-error">ERROR</span>`;
        const filePath = tu.input?.file_path || tu.input?.pattern || tu.input?.command?.slice(0, 60) || '';
        if (filePath) html += ` <span class="dim">${esc(String(filePath).slice(0, 80))}</span>`;
        if (result && result.preview) html += `<div class="drawer-tool-output">${esc(result.preview.slice(0, 300))}</div>`;
        html += `</li>`;
      }
      if (toolUses.length > 50) html += `<li class="dim">... and ${toolUses.length - 50} more</li>`;
      html += `</ul></div>`;
    }
  }

  if (data.files && data.files.length > 0) {
    html += `<div class="drawer-section"><h3>Files Touched (${data.files.length})</h3><ul class="drawer-file-list">`;
    for (const f of data.files.slice(0, 40)) {
      const ops = f.ops.map(o => {
        const cls = o === 'W' ? 'write' : o === 'E' ? 'edit' : 'read';
        return `<span class="file-op ${cls}">${o}</span>`;
      }).join('');
      html += `<li>${ops} <span class="dim">${esc(f.path)}</span></li>`;
    }
    if (data.files.length > 40) html += `<li class="dim">... and ${data.files.length - 40} more</li>`;
    html += `</ul></div>`;
  }

  if (data.errors && data.errors.length > 0) {
    html += `<div class="drawer-section"><h3>Errors (${data.errors.length})</h3>`;
    for (const err of data.errors.slice(0, 10)) {
      html += `<div class="drawer-error">${esc(err.text)}</div>`;
    }
    if (data.errors.length > 10) html += `<p class="dim" style="font-size:11px">... and ${data.errors.length - 10} more</p>`;
    html += `</div>`;
  }

  return html || `<div class="drawer-section"><p class="dim" style="padding:8px 0;font-size:11px">No transcript detail available</p></div>`;
}

// --- Compaction drawer ---

function openCompactionDrawer(idx, compaction) {
  const drawer = document.getElementById('detail-drawer');
  const body = document.getElementById('drawer-body');
  document.getElementById('drawer-title').textContent = `Compaction C${idx + 1}`;
  drawer.classList.add('open');

  const base = state.sessionStart || compaction.timestamp;
  let html = `<div class="drawer-section"><h3>Overview</h3><div class="drawer-kv">`;
  html += `<span class="k">Trigger</span><span class="v">${esc(compaction.trigger)}</span>`;
  html += `<span class="k">Time</span><span class="v">${formatTime(compaction.timestamp, base)}</span>`;
  html += `<span class="k">Index</span><span class="v">C${idx + 1} of ${state.compactions.length}</span>`;
  html += `</div></div>`;
  html += `<div class="drawer-section" id="compaction-summary-section"><div class="drawer-loading">Loading compaction summary...</div></div>`;
  body.innerHTML = html;

  // Async load summary from main agent's transcript
  const mainAgent = state.agents.get('ag_main');
  if (mainAgent && mainAgent.transcriptPath) {
    fetch(`/api/compaction-summary?path=${encodeURIComponent(mainAgent.transcriptPath)}&index=${idx}`)
      .then(r => r.ok ? r.json() : null)
      .then(data => {
        const section = document.getElementById('compaction-summary-section');
        if (!section) return;
        if (data && data.summary) {
          section.innerHTML = `<h3>Compacted Summary</h3><div class="drawer-prompt">${esc(data.summary)}</div>`;
        } else {
          section.innerHTML = `<h3>Compacted Summary</h3><p class="dim" style="padding:8px 0;font-size:11px">Summary not available in transcript</p>`;
        }
      })
      .catch(() => {
        const section = document.getElementById('compaction-summary-section');
        if (section) section.innerHTML = `<h3>Compacted Summary</h3><p class="dim" style="padding:8px 0;font-size:11px">Summary pending</p>`;
      });
  } else {
    const section = document.getElementById('compaction-summary-section');
    if (section) section.innerHTML = `<h3>Compacted Summary</h3><p class="dim" style="padding:8px 0;font-size:11px">No transcript path available</p>`;
  }
}

// --- Prompt source drawer ---

function openPromptDrawer(node) {
  const drawer = document.getElementById('detail-drawer');
  const body = document.getElementById('drawer-body');
  const pi = node.promptIndex;
  const cycleIdx = node.cycleIndex || 0;
  document.getElementById('drawer-title').textContent = `Turn ${pi + 1} — CTX ${cycleIdx + 1}`;
  drawer.classList.add('open');

  const prompt = state.userPrompts[pi];
  const base = state.sessionStart || 0;
  const nextPromptTime = state.userPrompts[pi + 1]?.timestamp || state.sessionEndTime || Date.now();
  const subCount = [...state.agents.values()].filter(a => a.parentId && a.spawnTime >= prompt.timestamp && a.spawnTime < nextPromptTime).length;
  const mainTools = state.toolCalls.filter(tc => tc.agentId === 'ag_main' && tc.startTime >= prompt.timestamp && tc.startTime < nextPromptTime);
  const totalTok = node.tokens || 0;
  const duration = (nextPromptTime - prompt.timestamp) / 1000;

  let html = `<div class="drawer-section"><h3>Prompt</h3><div class="drawer-prompt">${esc(prompt.text || '(empty)')}</div></div>`;
  html += `<div class="drawer-section"><h3>Overview</h3><div class="drawer-kv">`;
  html += `<span class="k">Turn</span><span class="v">${pi + 1}</span>`;
  html += `<span class="k">Context</span><span class="v">CTX ${cycleIdx + 1}</span>`;
  html += `<span class="k">Timestamp</span><span class="v">${formatTime(prompt.timestamp, base)}</span>`;
  html += `<span class="k">Duration</span><span class="v">${formatDuration(duration)}</span>`;
  html += `<span class="k">Sub-agents</span><span class="v">${subCount}</span>`;
  html += `<span class="k">Main tools</span><span class="v">${mainTools.length}</span>`;
  html += `<span class="k">Tokens</span><span class="v">${totalTok.toLocaleString()}</span>`;
  html += `</div></div>`;
  body.innerHTML = html;

  highlightPrompt(pi);
}

// --- Main Agent Work drawer ---

function openMainWorkDrawer(node) {
  const drawer = document.getElementById('detail-drawer');
  const body = document.getElementById('drawer-body');
  const pi = node.promptIndex;
  const cycleIdx = node.cycleIndex || 0;
  document.getElementById('drawer-title').textContent = `Main Agent — Turn ${pi !== undefined ? pi + 1 : '?'}`;
  drawer.classList.add('open');

  const tools = node.mainToolCalls || [];
  const totalTok = node.tokens || 0;
  const base = state.sessionStart || 0;

  // Group by category
  const categories = {
    'Analysis': ['Read', 'Grep', 'Glob', 'WebFetch', 'WebSearch'],
    'Modification': ['Edit', 'Write', 'NotebookEdit'],
    'Execution': ['Bash'],
  };
  const grouped = { 'Analysis': [], 'Modification': [], 'Execution': [], 'Other': [] };
  tools.forEach(tc => {
    let placed = false;
    for (const [cat, names] of Object.entries(categories)) {
      if (names.includes(tc.toolName)) { grouped[cat].push(tc); placed = true; break; }
    }
    if (!placed) grouped['Other'].push(tc);
  });

  // Count summary
  const countByName = {};
  tools.forEach(tc => { countByName[tc.toolName] = (countByName[tc.toolName] || 0) + 1; });
  const countStr = Object.entries(countByName).map(([k, v]) => `${v} ${k}`).join(', ');

  let html = `<div class="drawer-section"><h3>Overview</h3><div class="drawer-kv">`;
  if (node.subAgentCount !== undefined) html += `<span class="k">Sub-agents</span><span class="v">${node.subAgentCount}</span>`;
  if (node.model) html += `<span class="k">Model</span><span class="v">${esc(node.model)}</span>`;
  html += `<span class="k">Tools</span><span class="v">${tools.length} (${countStr})</span>`;
  html += `<span class="k">Tokens</span><span class="v">${totalTok.toLocaleString()}</span>`;
  if (tools.length > 0) {
    const earliest = Math.min(...tools.map(t => t.startTime));
    const latest = Math.max(...tools.map(t => t.endTime || t.startTime));
    const dur = (latest - earliest) / 1000;
    html += `<span class="k">Duration</span><span class="v">${formatDuration(dur)}</span>`;
  }
  html += `</div></div>`;

  // Tool list grouped by category
  for (const [cat, catTools] of Object.entries(grouped)) {
    if (catTools.length === 0) continue;
    html += `<div class="drawer-section"><div class="drawer-cat-header">${cat} (${catTools.length})</div>`;
    catTools.forEach(tc => {
      html += `<div class="drawer-tool-card"><div class="dtc-top">`;
      html += `<span class="dtc-name" style="color:var(--tool-${tc.toolName.toLowerCase()}, var(--accent))">${esc(tc.toolName)}</span>`;
      if (tc.params) html += `<span class="dtc-params" title="${esc(tc.params)}">${esc(tc.params.slice(0, 50))}</span>`;
      if (tc.hasError) html += `<span class="dtc-error-badge">ERR</span>`;
      html += `</div>`;
      const dur = tc.endTime ? ((tc.endTime - tc.startTime) / 1000).toFixed(1) + 's' : 'running';
      const tok = (tc.tokensIn || 0) + (tc.tokensOut || 0);
      html += `<div class="dtc-meta"><span>${formatTime(tc.startTime, base)}</span><span>${dur}</span>${tok ? `<span>${tok.toLocaleString()} tok</span>` : ''}</div>`;
      html += `</div>`;
    });
    html += `</div>`;
  }

  body.innerHTML = html;

  if (pi !== undefined) highlightPrompt(pi);
}

// --- Prompt highlight ---

function highlightPrompt(idx) {
  if (state.highlightedPromptIndex === idx) {
    state.highlightedPromptIndex = null;
    state.highlightTimestamp = null;
  } else {
    state.highlightedPromptIndex = idx;
    const prompt = state.userPrompts[idx];
    if (prompt) {
      state.highlightTimestamp = prompt.timestamp;
      // Also set context cycle highlight
      const cycleIdx = state.contextCycles.findIndex((c) => {
        const end = c.endTime || (state.sessionEndTime || Date.now());
        return prompt.timestamp >= c.startTime && prompt.timestamp < end;
      });
      if (cycleIdx >= 0) state.highlightedContextCycle = cycleIdx;
    }
  }
  render();
}

// --- Source node drawer ---

function openSourceDrawer(node) {
  const drawer = document.getElementById('detail-drawer');
  const body = document.getElementById('drawer-body');
  const cycleIdx = node.cycleIndex || 0;
  document.getElementById('drawer-title').textContent = `CTX ${cycleIdx + 1} — ${node.name}`;
  drawer.classList.add('open');

  const cycle = state.contextCycles[cycleIdx];
  const base = state.sessionStart || 0;
  const cycleAgents = [...state.agents.values()].filter(a => a.id !== 'ag_main' && isAgentInContextCycle(a, cycleIdx));
  const totalTok = cycleAgents.reduce((s, a) => s + a.tokensIn + a.tokensOut, 0);

  let html = `<div class="drawer-section"><h3>Overview</h3><div class="drawer-kv">`;
  html += `<span class="k">Trigger</span><span class="v">${esc(node.trigger || 'session_start')}</span>`;
  if (cycle) {
    html += `<span class="k">Start</span><span class="v">${formatTime(cycle.startTime, base)}</span>`;
    if (cycle.endTime) html += `<span class="k">End</span><span class="v">${formatTime(cycle.endTime, base)}</span>`;
  }
  html += `<span class="k">Agents</span><span class="v">${cycleAgents.length}</span>`;
  html += `<span class="k">Tokens</span><span class="v">${totalTok.toLocaleString()}</span>`;
  html += `</div></div>`;
  html += `<div class="drawer-section" id="source-content-section"><div class="drawer-loading">Loading...</div></div>`;
  body.innerHTML = html;

  highlightContextCycle(cycleIdx);

  // Async: load root prompt or compaction summary
  const mainAgent = state.agents.get('ag_main');
  const section = () => document.getElementById('source-content-section');

  if (cycleIdx === 0) {
    // CTX 1: fetch root prompt from transcript
    if (mainAgent && mainAgent.transcriptPath) {
      fetch(`/api/transcript?path=${encodeURIComponent(mainAgent.transcriptPath)}`)
        .then(r => r.ok ? r.json() : null)
        .then(data => {
          const el = section();
          if (!el) return;
          if (data && data.prompt) {
            el.innerHTML = `<h3>Root Prompt</h3><div class="drawer-prompt">${esc(data.prompt)}</div>`;
          } else {
            el.innerHTML = `<h3>Root Prompt</h3><p class="dim" style="padding:8px 0;font-size:11px">Prompt not available</p>`;
          }
        })
        .catch(() => {
          const el = section();
          if (el) el.innerHTML = `<h3>Root Prompt</h3><p class="dim" style="padding:8px 0;font-size:11px">Failed to load</p>`;
        });
    } else {
      const el = section();
      if (el) el.innerHTML = `<h3>Root Prompt</h3><p class="dim" style="padding:8px 0;font-size:11px">No transcript path</p>`;
    }
  } else {
    // CTX 2+: fetch compaction summary
    if (mainAgent && mainAgent.transcriptPath) {
      fetch(`/api/compaction-summary?path=${encodeURIComponent(mainAgent.transcriptPath)}&index=${cycleIdx - 1}`)
        .then(r => r.ok ? r.json() : null)
        .then(data => {
          const el = section();
          if (!el) return;
          if (data && data.summary) {
            el.innerHTML = `<h3>Compacted Summary</h3><div class="drawer-prompt">${esc(data.summary)}</div>`;
          } else {
            el.innerHTML = `<h3>Compacted Summary</h3><p class="dim" style="padding:8px 0;font-size:11px">Summary not available</p>`;
          }
        })
        .catch(() => {
          const el = section();
          if (el) el.innerHTML = `<h3>Compacted Summary</h3><p class="dim" style="padding:8px 0;font-size:11px">Failed to load</p>`;
        });
    } else {
      const el = section();
      if (el) el.innerHTML = `<h3>Compacted Summary</h3><p class="dim" style="padding:8px 0;font-size:11px">No transcript path</p>`;
    }
  }
}

// --- Phase node drawer ---

function openPhaseDrawer(node) {
  if (node.isDirectWork && node.mainToolCalls) return openMainWorkDrawer(node);
  const drawer = document.getElementById('detail-drawer');
  const body = document.getElementById('drawer-body');
  const cycleIdx = node.cycleIndex || 0;
  document.getElementById('drawer-title').textContent = `${node.name} — CTX ${cycleIdx + 1}`;
  drawer.classList.add('open');

  const phaseAgents = node.agents || [];
  const done = phaseAgents.filter(a => a.status === 'success').length;
  const err = phaseAgents.filter(a => a.status === 'error').length;
  const active = phaseAgents.filter(a => a.status === 'running').length;
  const totalTok = phaseAgents.reduce((s, a) => s + a.tokensIn + a.tokensOut, 0);

  let html = `<div class="drawer-section"><h3>Overview</h3><div class="drawer-kv">`;
  html += `<span class="k">Phase</span><span class="v">${esc(node.name)}</span>`;
  html += `<span class="k">Context</span><span class="v">CTX ${cycleIdx + 1}</span>`;
  html += `<span class="k">Agents</span><span class="v">${phaseAgents.length} (${done} done, ${err} err, ${active} active)</span>`;
  html += `<span class="k">Tokens</span><span class="v">${totalTok.toLocaleString()}</span>`;
  html += `</div></div>`;

  if (phaseAgents.length > 0) {
    html += `<div class="drawer-section"><h3>Agents</h3>`;
    phaseAgents.forEach(a => {
      const tokens = a.tokensIn + a.tokensOut;
      const dur = a.endTime ? ((a.endTime - a.spawnTime) / 1000).toFixed(1) + 's' : 'running';
      const statusCls = a.status === 'error' ? 'error' : a.status === 'running' ? 'running' : 'success';
      html += `<div class="drawer-agent-card" data-agent-id="${esc(a.id)}">`;
      html += `<div class="dac-top"><span class="dac-label">${esc(a.label)}</span><span class="dac-id">${esc(a.id.slice(-6))}</span>`;
      html += `<span class="agent-status-pill ${statusCls}" style="margin-left:auto;font-size:9px"><span class="pill-dot"></span>${esc(a.status)}</span></div>`;
      if (a.task) html += `<div class="dac-task" title="${esc(a.task)}">${esc(a.task.slice(0, 80))}</div>`;
      html += `<div class="dac-meta"><span>${tokens.toLocaleString()} tok</span><span>${dur}</span></div>`;
      html += `</div>`;
    });
    html += `</div>`;
  }

  body.innerHTML = html;

  // Make agent cards clickable
  body.querySelectorAll('.drawer-agent-card').forEach(card => {
    card.addEventListener('click', () => {
      const agentId = card.dataset.agentId;
      if (agentId) selectAgent(agentId);
    });
  });

  highlightContextCycle(cycleIdx);
}

// --- Context cycle linking ---

function highlightContextCycle(idx) {
  if (state.highlightedContextCycle === idx) {
    state.highlightedContextCycle = null;
    state.highlightedPromptIndex = null;
    state.highlightTimestamp = null;
  } else {
    state.highlightedContextCycle = idx;
    state.highlightedPromptIndex = null;
    const cycle = state.contextCycles[idx];
    if (cycle) state.highlightTimestamp = cycle.startTime;
    else state.highlightTimestamp = null;
  }
  render();
}

function isAgentInContextCycle(agent, cycleIdx) {
  if (cycleIdx === null || cycleIdx >= state.contextCycles.length) return true;
  if (agent.id === 'ag_main') return true;
  const cycle = state.contextCycles[cycleIdx];
  const start = cycle.startTime;
  const end = cycle.endTime || (state.sessionEndTime || Date.now());
  return agent.spawnTime >= start && agent.spawnTime < end;
}

function switchTab(tabName) {
  document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.sidebar-pane').forEach(p => { p.classList.remove('active'); p.style.display = 'none'; });
  const tab = document.querySelector(`.sidebar-tab[data-tab="${tabName}"]`);
  const pane = document.getElementById(`pane-${tabName}`);
  if (tab) tab.classList.add('active');
  if (pane) { pane.classList.add('active'); pane.style.display = tabName === 'events' ? 'flex' : 'block'; }
  state.activeTab = tabName;
}

// --- Event log ---

function renderEventLog() {
  const list = document.getElementById('event-log-list');
  if (!list || state.activeTab !== 'events') return;

  const filterText = (document.getElementById('event-filter-text')?.value || '').toLowerCase();
  const filterType = document.getElementById('event-filter-type')?.value || '';

  let events = state.events;

  // Filter by selected agent
  if (state.selectedAgentId) {
    events = events.filter(e => e.agent_id === state.selectedAgentId || e.spawns_agent_id === state.selectedAgentId);
  }

  // Filter by type
  if (filterType) {
    events = events.filter(e => e.event_type === filterType);
  }

  // Filter by text
  if (filterText) {
    events = events.filter(e => {
      const searchable = [e.event_type, e.tool_name, e.agent_label, e.tool_params_summary, e.tool_response_summary, e.trigger].filter(Boolean).join(' ').toLowerCase();
      return searchable.includes(filterText);
    });
  }

  // Cap at last 500
  const capped = events.slice(-500);
  const base = state.sessionStart || (capped[0]?.timestamp || Date.now());

  list.innerHTML = capped.map(e => {
    const time = formatTime(e.timestamp, base);
    const typeClass = e.event_type || '';
    const agentLabel = e.agent_label || '';
    const detail = e.tool_name
      ? `${e.tool_name}${e.tool_params_summary ? ' ' + e.tool_params_summary : ''}${e.tool_response_summary ? ' → ' + e.tool_response_summary : ''}`.slice(0, 100)
      : e.trigger ? `trigger: ${e.trigger}`
      : e.task_description ? e.task_description.slice(0, 100)
      : e.status || '';
    const highlighted = state.highlightedEventId === e.id ? 'highlighted' : '';

    return `<li class="event-log-item ${highlighted}" data-event-id="${e.id}" data-timestamp="${e.timestamp}">
      <span class="event-log-time">${time}</span>
      <span class="event-log-type ${typeClass}">${e.event_type}</span>
      <span class="event-log-agent">${esc(agentLabel)}</span>
      <span class="event-log-detail">${esc(detail)}</span>
    </li>`;
  }).join('');
}

function esc(str) {
  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function closeDrawer() {
  document.getElementById('detail-drawer').classList.remove('open');
}

// --- Context sidebar (CLAUDE.md + MEMORY.md) ---

let contextLoaded = false;

function getProjectPath() {
  for (let i = state.events.length - 1; i >= 0; i--) {
    if (state.events[i].cwd) return state.events[i].cwd;
  }
  return null;
}

function renderContextSection(label, data, truncationLine) {
  if (!data) return `<div class="context-section"><div class="context-section-header"><h3>${label}</h3><span class="ctx-meta">not found</span></div></div>`;
  const content = data.content || '';
  const lines = content.split('\n');
  const lineCount = data.lineCount || lines.length;

  let html = `<div class="context-section">`;
  const lineColor = lineCount >= 200 ? 'var(--red)' : 'var(--text-dim)';
  html += `<div class="context-section-header"><h3>${label}</h3><span class="ctx-meta" style="color:${lineColor}">${lineCount} lines</span></div>`;
  html += `<div class="context-path">${esc(data.path)}</div>`;

  if (truncationLine && lineCount > truncationLine) {
    const above = lines.slice(0, truncationLine).join('\n');
    const below = lines.slice(truncationLine).join('\n');
    html += `<div class="context-content">${esc(above)}</div>`;
    html += `<div class="context-truncation-mark">── Line ${truncationLine} — content below is truncated from system prompt ──</div>`;
    html += `<div class="context-content below-truncation">${esc(below)}</div>`;
  } else {
    html += `<div class="context-content">${esc(content)}</div>`;
  }
  html += `</div>`;
  return html;
}

async function loadContextTab() {
  const pane = document.getElementById('pane-context');
  if (!pane) return;

  const projectPath = getProjectPath();
  if (!projectPath) {
    pane.innerHTML = '<div class="context-empty">No project path detected from events</div>';
    return;
  }

  pane.innerHTML = '<div class="context-empty">Loading context...</div>';
  const enc = encodeURIComponent(projectPath);

  const [claudeRes, memRes] = await Promise.allSettled([
    fetch(`/api/claude-md?project=${enc}`).then(r => r.ok ? r.json() : null),
    fetch(`/api/memory?project=${enc}`).then(r => r.ok ? r.json() : null),
  ]);

  const claudeData = claudeRes.status === 'fulfilled' ? claudeRes.value : null;
  const memData = memRes.status === 'fulfilled' ? memRes.value : null;

  if (!claudeData && !memData) {
    pane.innerHTML = '<div class="context-empty">No CLAUDE.md or MEMORY.md found for this project</div>';
    return;
  }

  let html = '';
  if (claudeData) html += renderContextSection('CLAUDE.md', claudeData, null);
  if (memData) html += renderContextSection('MEMORY.md', memData, 200);
  pane.innerHTML = html;
  contextLoaded = true;
}

// --- Event listeners ---

// Sidebar tabs
document.querySelectorAll('.sidebar-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    switchTab(tab.dataset.tab);
    if (tab.dataset.tab === 'events') renderEventLog();
    if (tab.dataset.tab === 'context' && !contextLoaded) loadContextTab();
  });
});

document.getElementById('agent-cards-container').addEventListener('click', (e) => {
  const card = e.target.closest('.agent-card');
  if (card) selectAgent(card.dataset.agentId);
});

// Task list click → highlight owning agent
document.getElementById('task-list').addEventListener('click', (e) => {
  const item = e.target.closest('.task-item');
  if (!item) return;
  const taskId = item.dataset.taskId;
  const task = state.tasks.get(taskId);
  if (!task) return;
  // Find agent that matches this task
  for (const agent of state.agents.values()) {
    if (agent.task && task.subject && fuzzyMatch(agent.task, task.subject)) {
      selectAgent(agent.id);
      return;
    }
  }
});

// Plan cycle card click — highlight the context cycle this plan falls within
document.getElementById('plan-panel').addEventListener('click', (e) => {
  const card = e.target.closest('.plan-cycle-card');
  if (card) {
    const planIdx = parseInt(card.dataset.cycleIdx, 10);
    const plan = state.planCycles[planIdx];
    if (plan) {
      // Find the context cycle containing this plan
      const ctxIdx = state.contextCycles.findIndex(ctx => {
        const end = ctx.endTime || (state.sessionEndTime || Date.now());
        return plan.startTime >= ctx.startTime && plan.startTime < end;
      });
      if (ctxIdx >= 0) highlightContextCycle(ctxIdx);
    }
  }
});

// Event log click → timeline sync
document.getElementById('event-log-list').addEventListener('click', (e) => {
  const item = e.target.closest('.event-log-item');
  if (!item) return;
  const ts = parseInt(item.dataset.timestamp, 10);
  const id = item.dataset.eventId;
  state.highlightTimestamp = ts;
  state.highlightedEventId = id;
  render();
});

// Event log filters
document.getElementById('event-filter-text').addEventListener('input', () => renderEventLog());
document.getElementById('event-filter-type').addEventListener('change', () => renderEventLog());

document.getElementById('filter-active').addEventListener('click', () => {
  sessionFilter = 'active';
  document.getElementById('filter-active').classList.add('active');
  document.getElementById('filter-all').classList.remove('active');
  renderSessionDropdown();
  const sel = document.getElementById('session-select');
  if (sel.value) loadSession(sel.value);
});

document.getElementById('filter-all').addEventListener('click', () => {
  sessionFilter = 'all';
  document.getElementById('filter-all').classList.add('active');
  document.getElementById('filter-active').classList.remove('active');
  renderSessionDropdown();
  const sel = document.getElementById('session-select');
  if (sel.value) loadSession(sel.value);
});

document.getElementById('session-select').addEventListener('change', (e) => {
  if (e.target.value) loadSession(e.target.value);
});

document.querySelectorAll('.panel').forEach(panel => {
  panel.addEventListener('click', (e) => {
    if (e.target === panel || e.target.classList.contains('panel-header')) {
      state.selectedAgentId = null;
      state.highlightTimestamp = null;
      state.highlightedEventId = null;
      state.highlightedContextCycle = null;
      state.highlightedPromptIndex = null;
      closeDrawer();
      render();
    }
  });
});

document.getElementById('drawer-close').addEventListener('click', () => {
  state.selectedAgentId = null;
  state.highlightedPromptIndex = null;
  closeDrawer();
  render();
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    state.selectedAgentId = null;
    state.highlightTimestamp = null;
    state.highlightedEventId = null;
    state.highlightedContextCycle = null;
    state.highlightedPromptIndex = null;
    closeDrawer();
    render();
  }
  if (e.key === ' ' && !e.target.closest('input, select, textarea')) {
    e.preventDefault();
    state.paused = !state.paused;
    document.getElementById('status-text').textContent = state.paused ? 'Paused' : 'Connected';
  }
});

document.addEventListener('agent-select', (e) => {
  const { agentId } = e.detail;
  if (agentId) {
    const card = document.querySelector(`.agent-card[data-agent-id="${agentId}"]`);
    if (card) card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
});

// --- Tooltip ---

function showTooltip(event, html) {
  const tip = document.getElementById('tooltip');
  tip.innerHTML = html;
  tip.style.display = 'block';
  const tx = Math.min(event.pageX + 12, window.innerWidth - 320);
  const ty = Math.min(event.pageY + 12, window.innerHeight - 100);
  tip.style.left = tx + 'px';
  tip.style.top = ty + 'px';
}

function hideTooltip() {
  document.getElementById('tooltip').style.display = 'none';
}

// --- Init ---

(async function init() {
  await loadSessions();
  const sel = document.getElementById('session-select');
  if (sel.value) {
    await loadSession(sel.value);
  }
  connectSSE();
  render();

  setInterval(() => {
    if (!state.paused && state.agents.size > 0) render();
  }, 2000);
})();
</script>
</body>
</html>
